# æœå‹™å±¤è¨­è¨ˆ

**æ–‡æª”ç‰ˆæœ¬**ï¼šv1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2024å¹´

---

## ğŸ“‹ æœå‹™å±¤æ¦‚è¿°

### è¨­è¨ˆåŸå‰‡

1. **å–®ä¸€è·è²¬**ï¼šæ¯å€‹æœå‹™åªè² è²¬ä¸€å€‹æ¥­å‹™é ˜åŸŸ
2. **ä¾è³´æ³¨å…¥**ï¼šé€šéæ§‹é€ å‡½æ•¸æ³¨å…¥ä¾è³´
3. **äº‹å‹™ç®¡ç†**ï¼šåœ¨Serviceå±¤ç®¡ç†æ•¸æ“šåº«äº‹å‹™
4. **éŒ¯èª¤è™•ç†**ï¼šçµ±ä¸€æ‹‹å‡ºè‡ªå®šç¾©éŒ¯èª¤
5. **æ—¥èªŒè¨˜éŒ„**ï¼šè¨˜éŒ„é—œéµæ¥­å‹™æ“ä½œ

### æœå‹™åŠƒåˆ†

```
services/
â”œâ”€â”€ auth.service.ts          # èªè­‰æœå‹™
â”œâ”€â”€ user.service.ts          # ç”¨æˆ¶æœå‹™
â”œâ”€â”€ pairing.service.ts       # é…å°æœå‹™
â”œâ”€â”€ case.service.ts          # æ¡ˆä»¶æœå‹™
â”œâ”€â”€ judgment.service.ts      # åˆ¤æ±ºæœå‹™
â”œâ”€â”€ reconciliation.service.ts # å’Œå¥½æ–¹æ¡ˆæœå‹™
â”œâ”€â”€ execution.service.ts     # åŸ·è¡Œæœå‹™
â”œâ”€â”€ ai.service.ts            # AIæœå‹™
â”œâ”€â”€ email.service.ts         # éƒµä»¶æœå‹™
â””â”€â”€ file.service.ts          # æ–‡ä»¶æœå‹™
```

---

## ğŸ” èªè­‰æœå‹™ (AuthService)

### è·è²¬

- ç”¨æˆ¶è¨»å†Š
- ç”¨æˆ¶ç™»éŒ„
- å¯†ç¢¼é‡ç½®
- éƒµä»¶é©—è­‰
- Tokenç”Ÿæˆå’Œé©—è­‰

### æ¥å£å®šç¾©

```typescript
interface AuthService {
  // è¨»å†Š
  register(data: RegisterDto): Promise<{ user: User; token: string }>;
  
  // ç™»éŒ„
  login(email: string, password: string): Promise<{ user: User; token: string }>;
  
  // ç™¼é€é©—è­‰ç¢¼
  sendVerificationCode(email: string, type: VerificationType): Promise<void>;
  
  // é©—è­‰éƒµä»¶
  verifyEmail(email: string, code: string): Promise<boolean>;
  
  // é‡ç½®å¯†ç¢¼
  resetPassword(email: string): Promise<void>;
  
  // ç¢ºèªé‡ç½®å¯†ç¢¼
  confirmResetPassword(email: string, code: string, newPassword: string): Promise<void>;
  
  // ç”ŸæˆToken
  generateToken(user: User): string;
  
  // é©—è­‰Token
  verifyToken(token: string): Promise<UserPayload>;
}
```

### å¯¦ç¾è¦é»

**1. è¨»å†Šæµç¨‹**ï¼š
```typescript
async register(data: RegisterDto): Promise<{ user: User; token: string }> {
  // 1. é©—è­‰éƒµç®±æ ¼å¼
  if (!this.isValidEmail(data.email)) {
    throw new AppError(400, 'INVALID_EMAIL', 'éƒµç®±æ ¼å¼éŒ¯èª¤');
  }
  
  // 2. æª¢æŸ¥éƒµç®±æ˜¯å¦å·²å­˜åœ¨
  const existingUser = await this.userRepository.findByEmail(data.email);
  if (existingUser) {
    throw new AppError(409, 'EMAIL_EXISTS', 'éƒµç®±å·²å­˜åœ¨');
  }
  
  // 3. é©—è­‰å¯†ç¢¼å¼·åº¦
  if (!this.isStrongPassword(data.password)) {
    throw new AppError(400, 'WEAK_PASSWORD', 'å¯†ç¢¼å¼·åº¦ä¸è¶³');
  }
  
  // 4. åŠ å¯†å¯†ç¢¼
  const passwordHash = await bcrypt.hash(data.password, 10);
  
  // 5. å‰µå»ºç”¨æˆ¶
  const user = await this.userRepository.create({
    email: data.email,
    password_hash: passwordHash,
    nickname: data.nickname,
    email_verified: false
  });
  
  // 6. ç™¼é€é©—è­‰éƒµä»¶
  await this.sendVerificationCode(data.email, 'register');
  
  // 7. ç”ŸæˆToken
  const token = this.generateToken(user);
  
  return { user, token };
}
```

**2. ç™»éŒ„æµç¨‹**ï¼š
```typescript
async login(email: string, password: string): Promise<{ user: User; token: string }> {
  // 1. æŸ¥æ‰¾ç”¨æˆ¶
  const user = await this.userRepository.findByEmail(email);
  if (!user) {
    throw new AppError(401, 'INVALID_CREDENTIALS', 'éƒµç®±æˆ–å¯†ç¢¼éŒ¯èª¤');
  }
  
  // 2. é©—è­‰å¯†ç¢¼
  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) {
    throw new AppError(401, 'INVALID_CREDENTIALS', 'éƒµç®±æˆ–å¯†ç¢¼éŒ¯èª¤');
  }
  
  // 3. æª¢æŸ¥å¸³è™Ÿç‹€æ…‹
  if (!user.is_active) {
    throw new AppError(403, 'ACCOUNT_INACTIVE', 'å¸³è™Ÿæœªæ¿€æ´»');
  }
  
  // 4. æ›´æ–°æœ€å¾Œç™»éŒ„æ™‚é–“
  await this.userRepository.updateLastLogin(user.id);
  
  // 5. ç”ŸæˆToken
  const token = this.generateToken(user);
  
  return { user, token };
}
```

**3. é©—è­‰ç¢¼ç®¡ç†**ï¼š
```typescript
async sendVerificationCode(email: string, type: VerificationType): Promise<void> {
  // 1. æª¢æŸ¥ç™¼é€é »ç‡ï¼ˆæ¯5åˆ†é˜ä¸€æ¬¡ï¼‰
  const recentCode = await this.emailVerificationRepository.findRecent(email, type);
  if (recentCode && recentCode.created_at > new Date(Date.now() - 5 * 60 * 1000)) {
    throw new AppError(429, 'RATE_LIMIT', 'è«‹ç¨å¾Œå†è©¦');
  }
  
  // 2. ç”Ÿæˆ6ä½é©—è­‰ç¢¼
  const code = this.generateCode(6);
  
  // 3. ä¿å­˜é©—è­‰ç¢¼ï¼ˆ5åˆ†é˜éæœŸï¼‰
  await this.emailVerificationRepository.create({
    email,
    code,
    type,
    expires_at: new Date(Date.now() + 5 * 60 * 1000)
  });
  
  // 4. ç™¼é€éƒµä»¶
  await this.emailService.sendVerificationCode(email, code, type);
}
```

---

## ğŸ‘¤ ç”¨æˆ¶æœå‹™ (UserService)

### è·è²¬

- ç²å–ç”¨æˆ¶è³‡æ–™
- æ›´æ–°ç”¨æˆ¶è³‡æ–™
- ç”¨æˆ¶è³‡æ–™é©—è­‰

### æ¥å£å®šç¾©

```typescript
interface UserService {
  // ç²å–ç”¨æˆ¶è³‡æ–™
  getProfile(userId: string): Promise<User>;
  
  // æ›´æ–°ç”¨æˆ¶è³‡æ–™
  updateProfile(userId: string, data: UpdateUserDto): Promise<User>;
  
  // é©—è­‰ç”¨æˆ¶è³‡æ–™
  validateUserData(data: UpdateUserDto): void;
}
```

### å¯¦ç¾è¦é»

```typescript
async updateProfile(userId: string, data: UpdateUserDto): Promise<User> {
  // 1. é©—è­‰æ•¸æ“š
  this.validateUserData(data);
  
  // 2. æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å­˜åœ¨
  const user = await this.userRepository.findById(userId);
  if (!user) {
    throw new AppError(404, 'USER_NOT_FOUND', 'ç”¨æˆ¶ä¸å­˜åœ¨');
  }
  
  // 3. æ›´æ–°è³‡æ–™
  const updatedUser = await this.userRepository.update(userId, {
    ...data,
    updated_at: new Date()
  });
  
  // 4. è¨˜éŒ„æ—¥èªŒ
  this.logger.info('User profile updated', { userId, fields: Object.keys(data) });
  
  return updatedUser;
}
```

---

## ğŸ’‘ é…å°æœå‹™ (PairingService)

### è·è²¬

- å‰µå»ºé…å°ï¼ˆç”Ÿæˆé‚€è«‹ç¢¼ï¼‰
- åŠ å…¥é…å°ï¼ˆä½¿ç”¨é‚€è«‹ç¢¼ï¼‰
- ç²å–é…å°ç‹€æ…‹
- é©—è­‰é…å°é—œä¿‚

### æ¥å£å®šç¾©

```typescript
interface PairingService {
  // å‰µå»ºé…å°ï¼ˆå®Œæ•´æ¨¡å¼ï¼‰
  createPairing(userId: string): Promise<Pairing>;
  
  // åŠ å…¥é…å°ï¼ˆå®Œæ•´æ¨¡å¼ï¼‰
  joinPairing(userId: string, inviteCode: string): Promise<Pairing>;
  
  // ç²å–é…å°ç‹€æ…‹
  getPairingStatus(userId: string): Promise<Pairing | null>;
  
  // é©—è­‰é…å°é—œä¿‚
  validatePairing(pairingId: string, userId: string): Promise<boolean>;
  
  // å‰µå»ºè‡¨æ™‚é…å°ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
  createTempPairing(sessionId: string): Promise<Pairing>;
  
  // é€šéSession IDç²å–é…å°ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
  getPairingBySessionId(sessionId: string): Promise<Pairing | null>;
}
```

### å¯¦ç¾è¦é»

**1. å‰µå»ºé…å°**ï¼š
```typescript
async createPairing(userId: string): Promise<Pairing> {
  // 1. æª¢æŸ¥æ˜¯å¦å·²æœ‰é…å°
  const existingPairing = await this.pairingRepository.findActiveByUserId(userId);
  if (existingPairing) {
    throw new AppError(409, 'ALREADY_PAIRED', 'å·²ç¶“æœ‰é…å°é—œä¿‚');
  }
  
  // 2. ç”Ÿæˆå”¯ä¸€é‚€è«‹ç¢¼ï¼ˆ6ä½å­—æ¯æ•¸å­—ï¼‰
  const inviteCode = this.generateInviteCode();
  
  // 3. å‰µå»ºé…å°è¨˜éŒ„ï¼ˆ24å°æ™‚éæœŸï¼‰
  const pairing = await this.pairingRepository.create({
    user1_id: userId,
    invite_code: inviteCode,
    status: 'pending',
    expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000)
  });
  
  return pairing;
}
```

**2. åŠ å…¥é…å°**ï¼š
```typescript
async joinPairing(userId: string, inviteCode: string): Promise<Pairing> {
  // 1. æŸ¥æ‰¾é…å°è¨˜éŒ„
  const pairing = await this.pairingRepository.findByInviteCode(inviteCode);
  if (!pairing) {
    throw new AppError(400, 'INVALID_CODE', 'é‚€è«‹ç¢¼ç„¡æ•ˆ');
  }
  
  // 2. æª¢æŸ¥æ˜¯å¦éæœŸ
  if (pairing.expires_at < new Date()) {
    throw new AppError(400, 'CODE_EXPIRED', 'é‚€è«‹ç¢¼å·²éæœŸ');
  }
  
  // 3. æª¢æŸ¥æ˜¯å¦å·²ä½¿ç”¨
  if (pairing.status !== 'pending') {
    throw new AppError(400, 'CODE_USED', 'é‚€è«‹ç¢¼å·²ä½¿ç”¨');
  }
  
  // 4. æª¢æŸ¥æ˜¯å¦è‡ªå·±é…å°
  if (pairing.user1_id === userId) {
    throw new AppError(400, 'SELF_PAIRING', 'ä¸èƒ½èˆ‡è‡ªå·±é…å°');
  }
  
  // 5. æ›´æ–°é…å°è¨˜éŒ„
  const updatedPairing = await this.pairingRepository.update(pairing.id, {
    user2_id: userId,
    status: 'active',
    confirmed_at: new Date()
  });
  
  // 6. ç™¼é€é€šçŸ¥éƒµä»¶
  await this.emailService.sendPairingNotification(pairing.user1_id, userId);
  
  return updatedPairing;
}
```

---

## ğŸ“ æ¡ˆä»¶æœå‹™ (CaseService)

### è·è²¬

- å‰µå»ºæ¡ˆä»¶ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
- å‰µå»ºæ¡ˆä»¶ï¼ˆå®Œæ•´æ¨¡å¼ï¼‰
- ç²å–æ¡ˆä»¶è©³æƒ…
- æ›´æ–°æ¡ˆä»¶é™³è¿°
- ä¸Šå‚³è­‰æ“š
- AIè‡ªå‹•åˆ¤æ–·æ¡ˆä»¶é¡å‹

### æ¥å£å®šç¾©

```typescript
interface CaseService {
  // å‰µå»ºæ¡ˆä»¶ï¼ˆå¿«é€Ÿé«”é©—ï¼‰
  createQuickCase(data: QuickCaseDto, sessionId: string): Promise<Case>;
  
  // å‰µå»ºæ¡ˆä»¶ï¼ˆå®Œæ•´æ¨¡å¼ï¼‰
  createCase(userId: string, data: CreateCaseDto): Promise<Case>;
  
  // ç²å–æ¡ˆä»¶è©³æƒ…
  getCaseById(caseId: string, userId?: string, sessionId?: string): Promise<Case>;
  
  // é€šéSession IDç²å–æ¡ˆä»¶ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
  getCaseBySessionId(sessionId: string): Promise<Case | null>;
  
  // æ›´æ–°æ¡ˆä»¶é™³è¿°
  updateStatement(caseId: string, userId: string, statement: string): Promise<Case>;
  
  // ä¸Šå‚³è­‰æ“š
  uploadEvidence(caseId: string, userId: string, file: File): Promise<Evidence>;
  
  // AIè‡ªå‹•åˆ¤æ–·æ¡ˆä»¶é¡å‹
  detectCaseType(plaintiffStatement: string, defendantStatement: string): Promise<string>;
}
```

### å¯¦ç¾è¦é»

**1. å‰µå»ºå¿«é€Ÿé«”é©—æ¡ˆä»¶**ï¼š
```typescript
async createQuickCase(data: QuickCaseDto, sessionId: string): Promise<Case> {
  // 0. é©—è­‰Session IDæ ¼å¼
  if (!sessionId || !sessionId.startsWith('guest_')) {
    throw new AppError(400, 'INVALID_SESSION_ID', 'ç„¡æ•ˆçš„Session IDæ ¼å¼');
  }
  
  // 1. é©—è­‰Sessionæ˜¯å¦å­˜åœ¨ä¸”æœªéæœŸ
  const session = await this.sessionService.getSession(sessionId);
  if (!session) {
    throw new AppError(401, 'SESSION_EXPIRED', 'Sessionå·²éæœŸæˆ–ä¸å­˜åœ¨');
  }
  
  // 2. é©—è­‰é™³è¿°é•·åº¦
  if (!data.plaintiff_statement || data.plaintiff_statement.trim().length < 50) {
    throw new AppError(400, 'INVALID_STATEMENT', 'åŸå‘Šé™³è¿°é•·åº¦å¿…é ˆè‡³å°‘50å­—');
  }
  
  if (data.plaintiff_statement.length > 2000) {
    throw new AppError(400, 'INVALID_STATEMENT', 'åŸå‘Šé™³è¿°é•·åº¦ä¸èƒ½è¶…é2000å­—');
  }
  
  if (!data.defendant_statement || data.defendant_statement.trim().length < 50) {
    throw new AppError(400, 'INVALID_STATEMENT', 'è¢«å‘Šé™³è¿°é•·åº¦å¿…é ˆè‡³å°‘50å­—');
  }
  
  if (data.defendant_statement.length > 2000) {
    throw new AppError(400, 'INVALID_STATEMENT', 'è¢«å‘Šé™³è¿°é•·åº¦ä¸èƒ½è¶…é2000å­—');
  }
  
  // 3. é©—è­‰è­‰æ“šæ•¸é‡
  if (data.evidence_urls && data.evidence_urls.length > 3) {
    throw new AppError(400, 'TOO_MANY_EVIDENCES', 'æœ€å¤šåªèƒ½ä¸Šå‚³3å¼µåœ–ç‰‡');
  }
  
  // 4. é©—è­‰è­‰æ“šURLæ ¼å¼
  if (data.evidence_urls) {
    for (const url of data.evidence_urls) {
      try {
        new URL(url); // é©—è­‰URLæ ¼å¼
      } catch {
        throw new AppError(400, 'INVALID_EVIDENCE_URL', 'ç„¡æ•ˆçš„è­‰æ“šURLæ ¼å¼');
      }
    }
  }
  
  // 5. AIè‡ªå‹•åˆ¤æ–·æ¡ˆä»¶é¡å‹ï¼ˆå¸¶éŒ¯èª¤è™•ç†ï¼‰
  let caseType: string;
  try {
    caseType = await this.detectCaseType(
      data.plaintiff_statement,
      data.defendant_statement
    );
  } catch (error) {
    this.logger.error('Failed to detect case type', { error, sessionId });
    caseType = 'å…¶ä»–è¡çª'; // é»˜èªé¡å‹
  }
  
  // 6. å‰µå»ºè‡¨æ™‚é…å°ï¼ˆç”¨æ–¼å¿«é€Ÿé«”é©—ï¼‰
  const tempPairing = await this.createTempPairing(sessionId);
  
  // 7. ç”Ÿæˆæ¡ˆä»¶æ¨™é¡Œï¼ˆå¸¶éŒ¯èª¤è™•ç†ï¼‰
  let title: string;
  try {
    title = this.generateTitle(data.plaintiff_statement);
  } catch (error) {
    this.logger.warn('Failed to generate title', { error });
    title = 'æ¡ˆä»¶-' + new Date().toLocaleDateString(); // é»˜èªæ¨™é¡Œ
  }
  
  // 8. å‰µå»ºæ¡ˆä»¶è¨˜éŒ„ï¼ˆä½¿ç”¨äº‹å‹™ç¢ºä¿æ•¸æ“šä¸€è‡´æ€§ï¼‰
  let case_: Case;
  try {
    case_ = await this.caseRepository.create({
      pairing_id: tempPairing.id,
      title,
      type: caseType,
      plaintiff_id: null, // å¿«é€Ÿé«”é©—æ¨¡å¼ï¼Œç„¡çœŸå¯¦ç”¨æˆ¶
      defendant_id: null, // å¿«é€Ÿé«”é©—æ¨¡å¼ï¼Œç„¡çœŸå¯¦ç”¨æˆ¶
      plaintiff_statement: data.plaintiff_statement.trim(),
      defendant_statement: data.defendant_statement.trim(),
      status: 'submitted',
      mode: 'quick', // æ¨™è¨˜ç‚ºå¿«é€Ÿé«”é©—æ¨¡å¼
      session_id: sessionId, // é—œè¯Session ID
      submitted_at: new Date()
    });
  } catch (error) {
    this.logger.error('Failed to create case', { error, sessionId });
    throw new AppError(500, 'CASE_CREATION_FAILED', 'æ¡ˆä»¶å‰µå»ºå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
  }
  
  // 9. ä¿å­˜è­‰æ“šï¼ˆå¦‚æœ‰ï¼Œå¸¶éŒ¯èª¤è™•ç†ï¼‰
  if (data.evidence_urls && data.evidence_urls.length > 0) {
    try {
      for (const url of data.evidence_urls) {
        await this.evidenceRepository.create({
          case_id: case_.id,
          file_url: url,
          file_type: 'image',
          user_id: null // å¿«é€Ÿé«”é©—æ¨¡å¼ï¼Œç„¡çœŸå¯¦ç”¨æˆ¶
        });
      }
    } catch (error) {
      this.logger.error('Failed to save evidences', { error, caseId: case_.id });
      // è­‰æ“šä¿å­˜å¤±æ•—ä¸å½±éŸ¿æ¡ˆä»¶å‰µå»ºï¼Œè¨˜éŒ„éŒ¯èª¤å³å¯
    }
  }
  
  // 10. æ›´æ–°Sessionï¼Œé—œè¯æ¡ˆä»¶ID
  try {
    await this.sessionService.addCaseToSession(sessionId, case_.id);
  } catch (error) {
    this.logger.warn('Failed to update session', { error, sessionId, caseId: case_.id });
    // Sessionæ›´æ–°å¤±æ•—ä¸å½±éŸ¿æ¡ˆä»¶å‰µå»º
  }
  
  // 11. ç•°æ­¥è§¸ç™¼AIåˆ¤æ±ºç”Ÿæˆï¼ˆä¸é˜»å¡éŸ¿æ‡‰ï¼‰
  this.judgmentService.generateJudgment(case_.id).catch(err => {
    this.logger.error('Failed to generate judgment', { caseId: case_.id, error: err });
    // åˆ¤æ±ºç”Ÿæˆå¤±æ•—ä¸å½±éŸ¿æ¡ˆä»¶å‰µå»ºï¼Œç”¨æˆ¶å¯ä»¥ç¨å¾Œé‡è©¦
  });
  
  return case_;
}
```

**1.1. å‰µå»ºè‡¨æ™‚é…å°**ï¼ˆæ–°å¢æ–¹æ³•ï¼‰ï¼š
```typescript
private async createTempPairing(sessionId: string): Promise<Pairing> {
  // æª¢æŸ¥æ˜¯å¦å·²æœ‰è‡¨æ™‚é…å°
  const existingPairing = await this.pairingRepository.findBySessionId(sessionId);
  if (existingPairing) {
    return existingPairing;
  }
  
  // å‰µå»ºè‡¨æ™‚é…å°
  const tempPairing = await this.pairingRepository.create({
    user1_id: null,
    user2_id: null,
    invite_code: null,
    status: 'temp',
    pairing_type: 'quick',
    session_id: sessionId,
    expires_at: null // å¿«é€Ÿé«”é©—æ¨¡å¼ä¸éæœŸ
  });
  
  return tempPairing;
}
```

**2. AIè‡ªå‹•åˆ¤æ–·æ¡ˆä»¶é¡å‹**ï¼š
```typescript
async detectCaseType(plaintiffStatement: string, defendantStatement: string): Promise<string> {
  // ä½¿ç”¨AIæœå‹™åˆ¤æ–·æ¡ˆä»¶é¡å‹
  const prompt = `è«‹åˆ†æä»¥ä¸‹å…©å€‹é™³è¿°ï¼Œåˆ¤æ–·æ¡ˆä»¶é¡å‹ã€‚æ¡ˆä»¶é¡å‹åŒ…æ‹¬ï¼š
1. ç”Ÿæ´»ç¿’æ…£è¡çª
2. æ¶ˆè²»æ±ºç­–è¡çª
3. ç¤¾äº¤é—œä¿‚è¡çª
4. åƒ¹å€¼è§€è¡çª
5. æƒ…æ„Ÿéœ€æ±‚è¡çª
6. å…¶ä»–è¡çª

åŸå‘Šé™³è¿°ï¼š${plaintiffStatement}
è¢«å‘Šé™³è¿°ï¼š${defendantStatement}

è«‹åªè¿”å›æ¡ˆä»¶é¡å‹åç¨±ï¼Œä¸è¦è¿”å›å…¶ä»–å…§å®¹ã€‚`;

  try {
    const response = await this.aiService.generateText(prompt, {
      max_tokens: 10,
      temperature: 0.3
    });
    
    // è§£æéŸ¿æ‡‰ï¼Œæå–æ¡ˆä»¶é¡å‹
    const caseType = this.parseCaseType(response);
    return caseType || 'å…¶ä»–è¡çª';
  } catch (error) {
    this.logger.error('Failed to detect case type', { error });
    return 'å…¶ä»–è¡çª'; // é»˜èªé¡å‹
  }
}
```

---

## âš–ï¸ åˆ¤æ±ºæœå‹™ (JudgmentService)

### è·è²¬

- ç”ŸæˆAIåˆ¤æ±º
- ç²å–åˆ¤æ±ºè©³æƒ…
- æ¥å—/æ‹’çµ•åˆ¤æ±º
- åˆ¤æ±ºç·©å­˜ç®¡ç†

### æ¥å£å®šç¾©

```typescript
interface JudgmentService {
  // ç”Ÿæˆåˆ¤æ±º
  generateJudgment(caseId: string): Promise<Judgment>;
  
  // ç²å–åˆ¤æ±º
  getJudgmentByCaseId(caseId: string): Promise<Judgment | null>;
  
  // æ¥å—åˆ¤æ±ºï¼ˆåƒ…å®Œæ•´æ¨¡å¼ï¼‰
  acceptJudgment(judgmentId: string, userId: string, accepted: boolean, rating?: number): Promise<Judgment>;
  
  // ç²å–åˆ¤æ±ºï¼ˆæ”¯æŒå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
  getJudgmentByCaseId(caseId: string, userId?: string, sessionId?: string): Promise<Judgment | null>;
  
  // æª¢æŸ¥ç·©å­˜
  checkCache(caseId: string): Promise<Judgment | null>;
}
```

### å¯¦ç¾è¦é»

**1. ç”Ÿæˆåˆ¤æ±º**ï¼š
```typescript
async generateJudgment(caseId: string): Promise<Judgment> {
  // 1. æª¢æŸ¥æ˜¯å¦å·²æœ‰åˆ¤æ±º
  const existing = await this.judgmentRepository.findByCaseId(caseId);
  if (existing) {
    return existing;
  }
  
  // 2. æª¢æŸ¥ç·©å­˜
  const cached = await this.checkCache(caseId);
  if (cached) {
    return cached;
  }
  
  // 3. ç²å–æ¡ˆä»¶ä¿¡æ¯
  const case_ = await this.caseRepository.findById(caseId);
  if (!case_) {
    throw new AppError(404, 'CASE_NOT_FOUND', 'æ¡ˆä»¶ä¸å­˜åœ¨');
  }
  
  if (case_.status !== 'submitted') {
    throw new AppError(422, 'CASE_NOT_READY', 'æ¡ˆä»¶å°šæœªæº–å‚™å¥½');
  }
  
  // 4. æ§‹å»ºPrompt
  const prompt = this.buildJudgmentPrompt(case_);
  
  // 5. èª¿ç”¨AIæœå‹™ç”Ÿæˆåˆ¤æ±º
  let judgmentContent: string;
  let responsibilityRatio: { plaintiff: number; defendant: number };
  
  try {
    const response = await this.aiService.generateJudgment(prompt);
    judgmentContent = response.content;
    responsibilityRatio = response.responsibilityRatio;
  } catch (error) {
    this.logger.error('AI service error', { caseId, error });
    throw new AppError(503, 'AI_SERVICE_ERROR', 'AIæœå‹™æš«æ™‚ä¸å¯ç”¨');
  }
  
  // 6. ç”Ÿæˆæ‘˜è¦
  const summary = this.extractSummary(judgmentContent);
  
  // 7. ä¿å­˜åˆ¤æ±º
  const judgment = await this.judgmentRepository.create({
    case_id: caseId,
    judgment_content: judgmentContent,
    summary,
    responsibility_ratio: responsibilityRatio,
    ai_model: 'gpt-3.5-turbo',
    prompt_version: 'v1.0'
  });
  
  // 8. æ›´æ–°æ¡ˆä»¶ç‹€æ…‹
  await this.caseRepository.update(caseId, {
    status: 'completed',
    completed_at: new Date()
  });
  
  // 9. ç·©å­˜åˆ¤æ±ºï¼ˆ24å°æ™‚ï¼‰
  await this.cacheJudgment(caseId, judgment);
  
  // 10. ç™¼é€é€šçŸ¥éƒµä»¶ï¼ˆåƒ…å®Œæ•´æ¨¡å¼ï¼‰
  if (case_.mode !== 'quick' && case_.plaintiff_id) {
    await this.emailService.sendJudgmentNotification(case_.plaintiff_id, caseId);
    if (case_.defendant_id) {
      await this.emailService.sendJudgmentNotification(case_.defendant_id, caseId);
    }
  }
  
  // 11. å¿«é€Ÿé«”é©—æ¨¡å¼ï¼šæ¨™è¨˜Sessionç‚ºå·²å®Œæˆ
  if (case_.mode === 'quick' && case_.session_id) {
    await this.sessionService.markSessionCompleted(case_.session_id);
  }
  
  return judgment;
}
```

**2. æ§‹å»ºPrompt**ï¼š
```typescript
private buildJudgmentPrompt(case_: Case): string {
  return `è§’è‰²è¨­å®šï¼š
ä½ æ˜¯ä¸€ä½æº«æš–ã€å…¬æ­£çš„æ¯ç†Šæ³•å®˜ï¼Œä½ çš„ä½¿å‘½æ˜¯ä¿è­·å’Œå‘µè­·æ¯ä¸€å°æƒ…ä¾¶ã€‚
å³ä½¿æ˜¯åœ¨æ³•åº­ï¼Œä½ ä¹Ÿæœƒç”¨å¤§æ„›ã€åŒ…å®¹ã€ä¿è­·çš„æ–¹å¼å¹«åŠ©ä»–å€‘è§£æ±ºè¡çªã€‚

ä»»å‹™ï¼š
åŸºæ–¼ä»¥ä¸‹æ¡ˆä»¶ä¿¡æ¯ï¼Œç”Ÿæˆä¸€ä»½æº«æš–ã€å…¬æ­£ã€å¯¦ç”¨çš„åˆ¤æ±ºæ›¸ã€‚

æ¡ˆä»¶ä¿¡æ¯ï¼š
- æ¡ˆä»¶é¡å‹ï¼š${case_.type}
- åŸå‘Šé™³è¿°ï¼š${case_.plaintiff_statement}
- è¢«å‘Šé™³è¿°ï¼š${case_.defendant_statement || 'æš«ç„¡'}

åˆ¤æ±ºæ›¸è¦æ±‚ï¼š
1. å•é¡Œåˆ†æï¼ˆ200-300å­—ï¼‰ï¼š
   - è­˜åˆ¥æ ¸å¿ƒå•é¡Œ
   - åˆ†æé›™æ–¹ç«‹å ´
   - ç†è§£é›™æ–¹éœ€æ±‚

2. åˆ¤æ±ºçµæœï¼ˆ100-200å­—ï¼‰ï¼š
   - æ˜ç¢ºåˆ¤æ±ºï¼ˆæ”¯æŒåŸå‘Š/æ”¯æŒè¢«å‘Š/é›™æ–¹å„æ‰¿æ“”è²¬ä»»ï¼‰
   - è²¬ä»»åˆ†æ¯”ä¾‹ï¼ˆå¿…é ˆï¼‰ï¼š
     - ä»¥ç™¾åˆ†æ¯”å½¢å¼æ˜ç¢ºé›™æ–¹è²¬ä»»ï¼ˆå¦‚ï¼šåŸå‘Š60%ï¼Œè¢«å‘Š40%ï¼‰
     - èªªæ˜è²¬ä»»åˆ†é…çš„ç†ç”±
   - ç°¡è¦èªªæ˜ç†ç”±
   - å¼·èª¿ç†è§£å’ŒåŒ…å®¹

3. å…·é«”å»ºè­°ï¼ˆ300-500å­—ï¼‰ï¼š
   - æä¾›3-5æ¢å…·é«”è¡Œå‹•å»ºè­°
   - æ¯æ¢å»ºè­°è¦å¯åŸ·è¡Œ
   - å»ºè­°è¦æº«æš–ã€å¯¦ç”¨

4. é—œä¿‚ä¿®å¾©å»ºè­°ï¼ˆ200-300å­—ï¼‰ï¼š
   - å¦‚ä½•ä¿®å¾©é—œä¿‚
   - å¦‚ä½•é‡å»ºä¿¡ä»»
   - å¦‚ä½•é é˜²é¡ä¼¼è¡çª

èªè¨€é¢¨æ ¼ï¼š
- æº«æš–ã€è¦ªå’Œ
- å°ˆæ¥­ä½†ä¸å†·æ¼ 
- é¼“å‹µè€ŒéæŒ‡è²¬
- é«”ç¾ã€Œä¿è­·å’Œå‘µè­·ã€çš„ç†å¿µ

è¼¸å‡ºæ ¼å¼ï¼šMarkdownæ ¼å¼ï¼Œå¿…é ˆåŒ…å«è²¬ä»»åˆ†æ¯”ä¾‹ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
## âš–ï¸ åˆ¤æ±ºçµæœ
**è²¬ä»»åˆ†æ¯”ä¾‹**ï¼š
- åŸå‘Šï¼š[X]% è²¬ä»»
- è¢«å‘Šï¼š[Y]% è²¬ä»»
...`;
}
```

---

## ğŸ’ å’Œå¥½æ–¹æ¡ˆæœå‹™ (ReconciliationService)

### è·è²¬

- ç”Ÿæˆå’Œå¥½æ–¹æ¡ˆ
- ç²å–å’Œå¥½æ–¹æ¡ˆåˆ—è¡¨
- é¸æ“‡å’Œå¥½æ–¹æ¡ˆ
- æ–¹æ¡ˆæ¨è–¦ç®—æ³•

### æ¥å£å®šç¾©

```typescript
interface ReconciliationService {
  // ç”Ÿæˆå’Œå¥½æ–¹æ¡ˆ
  generatePlans(judgmentId: string, preferences?: PlanPreferences): Promise<ReconciliationPlan[]>;
  
  // ç²å–æ–¹æ¡ˆåˆ—è¡¨
  getPlansByJudgmentId(judgmentId: string, filters?: PlanFilters): Promise<ReconciliationPlan[]>;
  
  // é¸æ“‡æ–¹æ¡ˆ
  selectPlan(planId: string, userId: string): Promise<ReconciliationPlan>;
  
  // æ¨è–¦æ–¹æ¡ˆ
  recommendPlans(judgmentId: string, userId: string): Promise<ReconciliationPlan[]>;
}
```

### å¯¦ç¾è¦é»

**1. ç”Ÿæˆå’Œå¥½æ–¹æ¡ˆ**ï¼š
```typescript
async generatePlans(judgmentId: string, preferences?: PlanPreferences): Promise<ReconciliationPlan[]> {
  // 1. ç²å–åˆ¤æ±ºä¿¡æ¯
  const judgment = await this.judgmentRepository.findById(judgmentId);
  if (!judgment) {
    throw new AppError(404, 'JUDGMENT_NOT_FOUND', 'åˆ¤æ±ºä¸å­˜åœ¨');
  }
  
  // 2. ç²å–æ¡ˆä»¶ä¿¡æ¯
  const case_ = await this.caseRepository.findById(judgment.case_id);
  
  // 3. æ§‹å»ºPrompt
  const prompt = this.buildPlanPrompt(judgment, case_, preferences);
  
  // 4. èª¿ç”¨AIç”Ÿæˆæ–¹æ¡ˆ
  const plans = await this.aiService.generateReconciliationPlans(prompt);
  
  // 5. è¨ˆç®—é›£åº¦ç­‰ç´š
  const plansWithDifficulty = plans.map(plan => ({
    ...plan,
    difficulty_level: this.calculateDifficulty(plan),
    estimated_duration: this.estimateDuration(plan)
  }));
  
  // 6. ä¿å­˜æ–¹æ¡ˆ
  const savedPlans = await Promise.all(
    plansWithDifficulty.map(plan =>
      this.reconciliationPlanRepository.create({
        judgment_id: judgmentId,
        ...plan
      })
    )
  );
  
  return savedPlans;
}
```

**2. è¨ˆç®—é›£åº¦ç­‰ç´š**ï¼š
```typescript
private calculateDifficulty(plan: PlanContent): 'easy' | 'medium' | 'hard' {
  const totalScore = 
    plan.time_cost +
    plan.money_cost +
    plan.emotion_cost +
    plan.skill_requirement;
  
  if (totalScore <= 8) return 'easy';
  if (totalScore <= 12) return 'medium';
  return 'hard';
}
```

---

## âœ… åŸ·è¡Œæœå‹™ (ExecutionService)

### è·è²¬

- ç¢ºèªåŸ·è¡Œ
- åŸ·è¡Œæ‰“å¡
- ç²å–åŸ·è¡Œç‹€æ…‹
- åŸ·è¡Œè¿½è¹¤

### æ¥å£å®šç¾©

```typescript
interface ExecutionService {
  // ç¢ºèªåŸ·è¡Œ
  confirmExecution(userId: string, planId: string): Promise<ExecutionRecord>;
  
  // åŸ·è¡Œæ‰“å¡
  checkin(userId: string, planId: string, data: CheckinDto): Promise<ExecutionRecord>;
  
  // ç²å–åŸ·è¡Œç‹€æ…‹
  getExecutionStatus(userId: string, planId: string): Promise<ExecutionStatus>;
  
  // è¨ˆç®—åŸ·è¡Œé€²åº¦
  calculateProgress(planId: string): Promise<number>;
}
```

---

## ğŸ“š ç›¸é—œæ–‡æª”

- [å¾Œç«¯æ¶æ§‹è¨­è¨ˆ](./01-å¾Œç«¯æ¶æ§‹è¨­è¨ˆ.md)
- [æ•¸æ“šåº«è¨­è¨ˆ](./02-æ•¸æ“šåº«è¨­è¨ˆ.md)
- [APIè¨­è¨ˆ](./03-APIè¨­è¨ˆ.md)
- [AIæœå‹™é›†æˆ](./06-AIæœå‹™é›†æˆ.md)

---

**æ–‡æª”ç‰ˆæœ¬**ï¼šv1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2024å¹´

