# å…¶ä»–æœå‹™è¨­è¨ˆ

**æ–‡æª”ç‰ˆæœ¬**ï¼šv1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2024å¹´

---

## ğŸ“ æ–‡ä»¶å­˜å„²æœå‹™

### æœå‹™æ¦‚è¿°

è™•ç†ç”¨æˆ¶ä¸Šå‚³çš„æ–‡ä»¶ï¼ˆåœ–ç‰‡ã€è¦–é »ï¼‰ï¼ŒåŒ…æ‹¬é©—è­‰ã€è™•ç†ã€å­˜å„²ã€‚

### æŠ€è¡“é¸å‹

- **é–‹ç™¼ç’°å¢ƒ**ï¼šæœ¬åœ°æ–‡ä»¶ç³»çµ±
- **ç”Ÿç”¢ç’°å¢ƒ**ï¼šCloudinaryï¼ˆå…è²»é¡åº¦ï¼‰æˆ–AWS S3
- **åœ–ç‰‡è™•ç†**ï¼šSharpï¼ˆNode.jsï¼‰

### æ¥å£å®šç¾©

```typescript
interface FileService {
  // ä¸Šå‚³æ–‡ä»¶
  uploadFile(file: Express.Multer.File, userId: string): Promise<FileUploadResult>;
  
  // è™•ç†åœ–ç‰‡ï¼ˆå£“ç¸®ã€èª¿æ•´å¤§å°ï¼‰
  processImage(file: Express.Multer.File): Promise<Buffer>;
  
  // åˆªé™¤æ–‡ä»¶
  deleteFile(fileUrl: string): Promise<void>;
  
  // é©—è­‰æ–‡ä»¶
  validateFile(file: Express.Multer.File): void;
}
```

### å¯¦ç¾

**æ–‡ä»¶**ï¼š`src/services/file.service.ts`

```typescript
import multer from 'multer';
import sharp from 'sharp';
import path from 'path';
import fs from 'fs/promises';
import { AppError } from '../utils/errors';
import logger from '../config/logger';

export class FileService {
  private readonly allowedTypes = {
    image: ['image/jpeg', 'image/png', 'image/gif'],
    video: ['video/mp4']
  };
  
  private readonly maxFileSize = 5 * 1024 * 1024; // 5MB
  
  // é©—è­‰æ–‡ä»¶
  validateFile(file: Express.Multer.File): void {
    // æª¢æŸ¥æ–‡ä»¶å¤§å°
    if (file.size > this.maxFileSize) {
      throw new AppError(413, 'FILE_TOO_LARGE', 'æ–‡ä»¶å¤§å°ä¸èƒ½è¶…é5MB');
    }
    
    // æª¢æŸ¥æ–‡ä»¶é¡å‹
    const isValidImage = this.allowedTypes.image.includes(file.mimetype);
    const isValidVideo = this.allowedTypes.video.includes(file.mimetype);
    
    if (!isValidImage && !isValidVideo) {
      throw new AppError(400, 'INVALID_FILE_TYPE', 'ä¸æ”¯æŒçš„æ–‡ä»¶é¡å‹ï¼Œåªæ”¯æŒJPGã€PNGã€GIFã€MP4');
    }
  }
  
  // è™•ç†åœ–ç‰‡
  async processImage(file: Express.Multer.File): Promise<Buffer> {
    try {
      // å£“ç¸®åœ–ç‰‡ï¼Œæœ€å¤§å°ºå¯¸1920x1080
      const processed = await sharp(file.buffer)
        .resize(1920, 1080, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({ quality: 85 }) // JPEGè³ªé‡85%
        .toBuffer();
      
      return processed;
    } catch (error) {
      logger.error('Image processing error', { error });
      throw new AppError(500, 'IMAGE_PROCESSING_ERROR', 'åœ–ç‰‡è™•ç†å¤±æ•—');
    }
  }
  
  // ä¸Šå‚³æ–‡ä»¶ï¼ˆæœ¬åœ°å­˜å„²ï¼‰
  async uploadFileLocal(
    file: Express.Multer.File,
    userId: string
  ): Promise<FileUploadResult> {
    // é©—è­‰æ–‡ä»¶
    this.validateFile(file);
    
    // è™•ç†åœ–ç‰‡
    let processedBuffer: Buffer;
    if (this.allowedTypes.image.includes(file.mimetype)) {
      processedBuffer = await this.processImage(file);
    } else {
      processedBuffer = file.buffer;
    }
    
    // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
    const ext = path.extname(file.originalname);
    const filename = `${Date.now()}-${Math.round(Math.random() * 1E9)}${ext}`;
    const filepath = path.join('uploads', userId, filename);
    
    // ç¢ºä¿ç›®éŒ„å­˜åœ¨
    const dir = path.dirname(filepath);
    await fs.mkdir(dir, { recursive: true });
    
    // ä¿å­˜æ–‡ä»¶
    await fs.writeFile(filepath, processedBuffer);
    
    // ç”ŸæˆURLï¼ˆé–‹ç™¼ç’°å¢ƒï¼‰
    const fileUrl = `/uploads/${userId}/${filename}`;
    
    return {
      url: fileUrl,
      filename,
      size: processedBuffer.length,
      type: file.mimetype
    };
  }
  
  // ä¸Šå‚³æ–‡ä»¶ï¼ˆCloudinaryï¼‰
  async uploadFileCloudinary(
    file: Express.Multer.File,
    userId: string
  ): Promise<FileUploadResult> {
    const cloudinary = require('cloudinary').v2;
    
    // é©—è­‰æ–‡ä»¶
    this.validateFile(file);
    
    // è™•ç†åœ–ç‰‡
    let uploadBuffer: Buffer;
    if (this.allowedTypes.image.includes(file.mimetype)) {
      uploadBuffer = await this.processImage(file);
    } else {
      uploadBuffer = file.buffer;
    }
    
    // ä¸Šå‚³åˆ°Cloudinary
    return new Promise((resolve, reject) => {
      cloudinary.uploader.upload_stream(
        {
          folder: `mother-bear-court/${userId}`,
          resource_type: 'auto',
          transformation: [
            { width: 1920, height: 1080, crop: 'limit' },
            { quality: 'auto' }
          ]
        },
        (error: any, result: any) => {
          if (error) {
            reject(new AppError(500, 'UPLOAD_ERROR', 'æ–‡ä»¶ä¸Šå‚³å¤±æ•—'));
          } else {
            resolve({
              url: result.secure_url,
              filename: result.public_id,
              size: result.bytes,
              type: result.resource_type
            });
          }
        }
      ).end(uploadBuffer);
    });
  }
  
  // åˆªé™¤æ–‡ä»¶
  async deleteFile(fileUrl: string): Promise<void> {
    try {
      // åˆ¤æ–·æ˜¯æœ¬åœ°æ–‡ä»¶é‚„æ˜¯Cloudinaryæ–‡ä»¶
      if (fileUrl.startsWith('http')) {
        // Cloudinaryæ–‡ä»¶
        const cloudinary = require('cloudinary').v2;
        const publicId = this.extractPublicId(fileUrl);
        await cloudinary.uploader.destroy(publicId);
      } else {
        // æœ¬åœ°æ–‡ä»¶
        const filepath = path.join(process.cwd(), fileUrl);
        await fs.unlink(filepath);
      }
    } catch (error) {
      logger.error('File deletion error', { fileUrl, error });
      // ä¸æ‹‹å‡ºéŒ¯èª¤ï¼Œå…è¨±åˆªé™¤å¤±æ•—
    }
  }
}
```

### Multeré…ç½®

```typescript
import multer from 'multer';
import path from 'path';

const storage = multer.memoryStorage(); // ä½¿ç”¨å…§å­˜å­˜å„²ï¼Œè™•ç†å¾Œå†ä¿å­˜

export const upload = multer({
  storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new AppError(400, 'INVALID_FILE_TYPE', 'ä¸æ”¯æŒçš„æ–‡ä»¶é¡å‹'));
    }
  }
});
```

---

## ğŸ“§ éƒµä»¶æœå‹™

### æœå‹™æ¦‚è¿°

ç™¼é€å„ç¨®éƒµä»¶é€šçŸ¥ï¼ŒåŒ…æ‹¬è¨»å†Šé©—è­‰ã€é…å°é€šçŸ¥ã€åˆ¤æ±ºé€šçŸ¥ç­‰ã€‚

### æŠ€è¡“é¸å‹

- **é–‹ç™¼ç’°å¢ƒ**ï¼šNodemailerï¼ˆæœ¬åœ°SMTPï¼‰
- **ç”Ÿç”¢ç’°å¢ƒ**ï¼šSendGridï¼ˆå…è²»é¡åº¦ï¼‰æˆ–Nodemailer

### æ¥å£å®šç¾©

```typescript
interface EmailService {
  // ç™¼é€é©—è­‰ç¢¼
  sendVerificationCode(email: string, code: string, type: VerificationType): Promise<void>;
  
  // ç™¼é€é…å°é€šçŸ¥
  sendPairingNotification(userId: string, partnerId: string): Promise<void>;
  
  // ç™¼é€åˆ¤æ±ºé€šçŸ¥
  sendJudgmentNotification(userId: string, caseId: string): Promise<void>;
  
  // ç™¼é€å’Œå¥½æ–¹æ¡ˆé€šçŸ¥
  sendReconciliationPlanNotification(userId: string, planId: string): Promise<void>;
}
```

### å¯¦ç¾

**æ–‡ä»¶**ï¼š`src/services/email.service.ts`

```typescript
import nodemailer from 'nodemailer';
import { AppError } from '../utils/errors';
import logger from '../config/logger';

export class EmailService {
  private transporter: nodemailer.Transporter;
  
  constructor() {
    // æ ¹æ“šç’°å¢ƒé¸æ“‡éƒµä»¶æœå‹™
    if (process.env.NODE_ENV === 'production' && process.env.SENDGRID_API_KEY) {
      // ä½¿ç”¨SendGrid
      this.transporter = nodemailer.createTransport({
        service: 'SendGrid',
        auth: {
          user: 'apikey',
          pass: process.env.SENDGRID_API_KEY
        }
      });
    } else {
      // ä½¿ç”¨SMTPï¼ˆé–‹ç™¼ç’°å¢ƒï¼‰
      this.transporter = nodemailer.createTransport({
        host: process.env.SMTP_HOST || 'smtp.gmail.com',
        port: parseInt(process.env.SMTP_PORT || '587'),
        secure: false,
        auth: {
          user: process.env.SMTP_USER,
          pass: process.env.SMTP_PASS
        }
      });
    }
  }
  
  // ç™¼é€é©—è­‰ç¢¼
  async sendVerificationCode(
    email: string,
    code: string,
    type: VerificationType
  ): Promise<void> {
    const subject = this.getVerificationSubject(type);
    const html = this.getVerificationTemplate(code, type);
    
    try {
      await this.transporter.sendMail({
        from: process.env.EMAIL_FROM || 'noreply@motherbearcourt.com',
        to: email,
        subject,
        html
      });
      
      logger.info('Verification code sent', { email, type });
    } catch (error) {
      logger.error('Failed to send verification code', { email, error });
      throw new AppError(500, 'EMAIL_SEND_ERROR', 'éƒµä»¶ç™¼é€å¤±æ•—');
    }
  }
  
  // ç™¼é€é…å°é€šçŸ¥
  async sendPairingNotification(userId: string, partnerId: string): Promise<void> {
    // ç²å–ç”¨æˆ¶ä¿¡æ¯
    const user = await userRepository.findById(userId);
    const partner = await userRepository.findById(partnerId);
    
    if (!user || !partner) {
      throw new AppError(404, 'USER_NOT_FOUND', 'ç”¨æˆ¶ä¸å­˜åœ¨');
    }
    
    const html = `
      <h2>é…å°æˆåŠŸï¼</h2>
      <p>ä½ å¥½ ${user.nickname}ï¼Œ</p>
      <p>ä½ å·²æˆåŠŸèˆ‡ ${partner.nickname} é…å°ï¼</p>
      <p>ç¾åœ¨ä½ å€‘å¯ä»¥é–‹å§‹ä½¿ç”¨ç†Šåª½åª½æ³•åº­è§£æ±ºè¡çªäº†ã€‚</p>
      <p><a href="${process.env.FRONTEND_URL}/pairing">æŸ¥çœ‹é…å°è©³æƒ…</a></p>
    `;
    
    await this.transporter.sendMail({
      from: process.env.EMAIL_FROM,
      to: user.email,
      subject: 'é…å°æˆåŠŸ - ç†Šåª½åª½æ³•åº­',
      html
    });
  }
  
  // ç™¼é€åˆ¤æ±ºé€šçŸ¥
  async sendJudgmentNotification(userId: string, caseId: string): Promise<void> {
    const user = await userRepository.findById(userId);
    const case_ = await caseRepository.findById(caseId);
    
    if (!user || !case_) {
      return;
    }
    
    const html = `
      <h2>åˆ¤æ±ºå·²ç”Ÿæˆ</h2>
      <p>ä½ å¥½ ${user.nickname}ï¼Œ</p>
      <p>ä½ çš„æ¡ˆä»¶ã€Œ${case_.title}ã€çš„åˆ¤æ±ºå·²ç¶“ç”Ÿæˆã€‚</p>
      <p><a href="${process.env.FRONTEND_URL}/cases/${caseId}/judgment">æŸ¥çœ‹åˆ¤æ±º</a></p>
    `;
    
    await this.transporter.sendMail({
      from: process.env.EMAIL_FROM,
      to: user.email,
      subject: 'åˆ¤æ±ºå·²ç”Ÿæˆ - ç†Šåª½åª½æ³•åº­',
      html
    });
  }
  
  // ç²å–é©—è­‰ç¢¼éƒµä»¶ä¸»é¡Œ
  private getVerificationSubject(type: VerificationType): string {
    switch (type) {
      case 'register':
        return 'æ­¡è¿è¨»å†Šç†Šåª½åª½æ³•åº­ - è«‹é©—è­‰æ‚¨çš„éƒµç®±';
      case 'reset_password':
        return 'é‡ç½®å¯†ç¢¼ - ç†Šåª½åª½æ³•åº­';
      case 'verify_email':
        return 'é©—è­‰éƒµç®± - ç†Šåª½åª½æ³•åº­';
      default:
        return 'é©—è­‰ç¢¼ - ç†Šåª½åª½æ³•åº­';
    }
  }
  
  // ç²å–é©—è­‰ç¢¼éƒµä»¶æ¨¡æ¿
  private getVerificationTemplate(code: string, type: VerificationType): string {
    return `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2>ç†Šåª½åª½æ³•åº­</h2>
        <p>æ‚¨çš„é©—è­‰ç¢¼æ˜¯ï¼š</p>
        <div style="font-size: 32px; font-weight: bold; color: #8B4513; text-align: center; padding: 20px; background: #f5f5f5; border-radius: 8px; margin: 20px 0;">
          ${code}
        </div>
        <p>é©—è­‰ç¢¼æœ‰æ•ˆæœŸç‚º5åˆ†é˜ï¼Œè«‹å‹¿æ´©éœ²çµ¦ä»–äººã€‚</p>
        <p>å¦‚æœé€™ä¸æ˜¯æ‚¨çš„æ“ä½œï¼Œè«‹å¿½ç•¥æ­¤éƒµä»¶ã€‚</p>
      </div>
    `;
  }
}
```

---

## â° å®šæ™‚ä»»å‹™

### æœå‹™æ¦‚è¿°

è™•ç†å®šæ™‚åŸ·è¡Œçš„ä»»å‹™ï¼Œå¦‚éƒµä»¶å›è¨ªã€æ•¸æ“šæ¸…ç†ã€ç·©å­˜æ›´æ–°ç­‰ã€‚

### æŠ€è¡“é¸å‹

- **ä»»å‹™èª¿åº¦**ï¼šnode-cron

### ä»»å‹™åˆ—è¡¨

1. **éƒµä»¶å›è¨ªä»»å‹™**ï¼šåˆ¤æ±ºå¾Œ7å¤©ã€30å¤©è‡ªå‹•å›è¨ª
2. **æ•¸æ“šæ¸…ç†ä»»å‹™**ï¼šæ¸…ç†éæœŸé©—è­‰ç¢¼ã€æœªæ¿€æ´»ç”¨æˆ¶
3. **ç·©å­˜æ›´æ–°ä»»å‹™**ï¼šæ›´æ–°ç†±é»æ•¸æ“šç·©å­˜
4. **çµ±è¨ˆä»»å‹™**ï¼šç”Ÿæˆæ¯æ—¥çµ±è¨ˆå ±å‘Š

### å¯¦ç¾

**æ–‡ä»¶**ï¼š`src/jobs/followup.job.ts`

```typescript
import cron from 'node-cron';
import { CaseRepository } from '../repositories/case.repository';
import { EmailService } from '../services/email.service';
import logger from '../config/logger';

export class FollowupJob {
  constructor(
    private caseRepository: CaseRepository,
    private emailService: EmailService
  ) {}
  
  // å•Ÿå‹•ä»»å‹™
  start(): void {
    // æ¯å¤©å‡Œæ™¨2é»åŸ·è¡Œ
    cron.schedule('0 2 * * *', async () => {
      await this.checkFollowups();
    });
    
    logger.info('Followup job started');
  }
  
  // æª¢æŸ¥éœ€è¦å›è¨ªçš„æ¡ˆä»¶
  private async checkFollowups(): Promise<void> {
    try {
      // æŸ¥æ‰¾7å¤©å‰å®Œæˆçš„æ¡ˆä»¶
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      
      const cases7Days = await this.caseRepository.findCompletedAfter(sevenDaysAgo);
      
      for (const case_ of cases7Days) {
        // æª¢æŸ¥æ˜¯å¦å·²ç™¼é€7å¤©å›è¨ª
        if (!case_.followup_7days_sent) {
          await this.send7DayFollowup(case_);
          await this.caseRepository.update(case_.id, {
            followup_7days_sent: true
          });
        }
      }
      
      // æŸ¥æ‰¾30å¤©å‰å®Œæˆçš„æ¡ˆä»¶
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      
      const cases30Days = await this.caseRepository.findCompletedAfter(thirtyDaysAgo);
      
      for (const case_ of cases30Days) {
        // æª¢æŸ¥æ˜¯å¦å·²ç™¼é€30å¤©å›è¨ª
        if (!case_.followup_30days_sent) {
          await this.send30DayFollowup(case_);
          await this.caseRepository.update(case_.id, {
            followup_30days_sent: true
          });
        }
      }
      
      logger.info('Followup check completed', {
        sevenDays: cases7Days.length,
        thirtyDays: cases30Days.length
      });
    } catch (error) {
      logger.error('Followup job error', { error });
    }
  }
  
  // ç™¼é€7å¤©å›è¨ªéƒµä»¶
  private async send7DayFollowup(case_: Case): Promise<void> {
    const user = await userRepository.findById(case_.plaintiff_id);
    if (user && user.notification_enabled) {
      await this.emailService.sendFollowupEmail(
        user.email,
        case_.id,
        '7days'
      );
    }
  }
  
  // ç™¼é€30å¤©å›è¨ªéƒµä»¶
  private async send30DayFollowup(case_: Case): Promise<void> {
    const user = await userRepository.findById(case_.plaintiff_id);
    if (user && user.notification_enabled) {
      await this.emailService.sendFollowupEmail(
        user.email,
        case_.id,
        '30days'
      );
    }
  }
}
```

**æ–‡ä»¶**ï¼š`src/jobs/cleanup.job.ts`

```typescript
import cron from 'node-cron';
import { EmailVerificationRepository } from '../repositories/email-verification.repository';
import logger from '../config/logger';

export class CleanupJob {
  constructor(
    private emailVerificationRepository: EmailVerificationRepository
  ) {}
  
  // å•Ÿå‹•ä»»å‹™
  start(): void {
    // æ¯å°æ™‚åŸ·è¡Œä¸€æ¬¡
    cron.schedule('0 * * * *', async () => {
      await this.cleanupExpiredVerifications();
    });
    
    logger.info('Cleanup job started');
  }
  
  // æ¸…ç†éæœŸé©—è­‰ç¢¼
  private async cleanupExpiredVerifications(): Promise<void> {
    try {
      const now = new Date();
      const deleted = await this.emailVerificationRepository.deleteExpired(now);
      
      logger.info('Expired verifications cleaned', { count: deleted });
    } catch (error) {
      logger.error('Cleanup job error', { error });
    }
  }
}
```

### ä»»å‹™å•Ÿå‹•

**æ–‡ä»¶**ï¼š`src/app.ts`

```typescript
import { FollowupJob } from './jobs/followup.job';
import { CleanupJob } from './jobs/cleanup.job';

// å•Ÿå‹•å®šæ™‚ä»»å‹™
if (process.env.NODE_ENV !== 'test') {
  const followupJob = new FollowupJob(caseRepository, emailService);
  followupJob.start();
  
  const cleanupJob = new CleanupJob(emailVerificationRepository);
  cleanupJob.start();
}
```

---

## ğŸ“Š æ—¥èªŒæœå‹™

### æ—¥èªŒé…ç½®

**æ–‡ä»¶**ï¼š`src/config/logger.ts`

```typescript
import winston from 'winston';

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    // éŒ¯èª¤æ—¥èªŒ
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error'
    }),
    // æ‰€æœ‰æ—¥èªŒ
    new winston.transports.File({
      filename: 'logs/combined.log'
    })
  ]
});

// é–‹ç™¼ç’°å¢ƒè¼¸å‡ºåˆ°æ§åˆ¶å°
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}
```

---

## ğŸ”„ Sessionç®¡ç†ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰

### Sessionå­˜å„²

**æ–‡ä»¶**ï¼š`src/services/session.service.ts`

```typescript
import { v4 as uuidv4 } from 'uuid';
import { CaseRepository } from '../repositories/case.repository';
import { AppError } from '../utils/errors';
import logger from '../config/logger';

interface SessionData {
  id: string;
  createdAt: Date;
  expiresAt: Date;
  caseIds: string[];
  pairingId?: string;
  lastAccessedAt: Date;
}

export class SessionService {
  private sessionTTL = 24 * 60 * 60 * 1000; // 24å°æ™‚
  private completedSessionTTL = 7 * 24 * 60 * 60 * 1000; // 7å¤©ï¼ˆå·²å®Œæˆçš„æ¡ˆä»¶ï¼‰
  
  // ç”ŸæˆSession IDï¼ˆæ ¼å¼ï¼šguest_timestamp_randomï¼‰
  generateSessionId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    return `guest_${timestamp}_${random}`;
  }
  
  // å‰µå»ºSession
  async createSession(): Promise<string> {
    const sessionId = this.generateSessionId();
    const now = new Date();
    const expiresAt = new Date(now.getTime() + this.sessionTTL);
    
    const sessionData: SessionData = {
      id: sessionId,
      createdAt: now,
      expiresAt,
      caseIds: [],
      lastAccessedAt: now
    };
    
    // å­˜å„²åˆ°Redisæˆ–æ•¸æ“šåº«
    await this.saveSession(sessionId, sessionData);
    
    logger.info('Session created', { sessionId });
    
    return sessionId;
  }
  
  // ç²å–Session
  async getSession(sessionId: string): Promise<SessionData | null> {
    // é©—è­‰Session IDæ ¼å¼
    if (!sessionId.startsWith('guest_')) {
      return null;
    }
    
    const session = await this.loadSession(sessionId);
    if (!session) {
      return null;
    }
    
    // æª¢æŸ¥æ˜¯å¦éæœŸ
    if (new Date() > session.expiresAt) {
      await this.deleteSession(sessionId);
      return null;
    }
    
    // æ›´æ–°æœ€å¾Œè¨ªå•æ™‚é–“
    session.lastAccessedAt = new Date();
    await this.saveSession(sessionId, sessionData);
    
    return session;
  }
  
  // æ·»åŠ æ¡ˆä»¶åˆ°Session
  async addCaseToSession(sessionId: string, caseId: string): Promise<void> {
    const session = await this.getSession(sessionId);
    if (!session) {
      throw new AppError(401, 'SESSION_EXPIRED', 'Sessionå·²éæœŸ');
    }
    
    if (!session.caseIds.includes(caseId)) {
      session.caseIds.push(caseId);
      await this.saveSession(sessionId, session);
    }
  }
  
  // è¨­ç½®é…å°ID
  async setPairingId(sessionId: string, pairingId: string): Promise<void> {
    const session = await this.getSession(sessionId);
    if (!session) {
      throw new AppError(401, 'SESSION_EXPIRED', 'Sessionå·²éæœŸ');
    }
    
    session.pairingId = pairingId;
    await this.saveSession(sessionId, session);
  }
  
  // æ¨™è¨˜Sessionç‚ºå·²å®Œæˆï¼ˆå»¶é•·éæœŸæ™‚é–“ï¼‰
  async markSessionCompleted(sessionId: string): Promise<void> {
    const session = await this.getSession(sessionId);
    if (!session) {
      return;
    }
    
    // å»¶é•·éæœŸæ™‚é–“åˆ°7å¤©
    session.expiresAt = new Date(Date.now() + this.completedSessionTTL);
    await this.saveSession(sessionId, session);
  }
  
  // ä¿å­˜Sessionï¼ˆä½¿ç”¨Redisæˆ–æ•¸æ“šåº«ï¼‰
  private async saveSession(sessionId: string, data: SessionData): Promise<void> {
    // å„ªå…ˆä½¿ç”¨Redis
    if (process.env.REDIS_URL) {
      const redis = require('redis').createClient({ url: process.env.REDIS_URL });
      await redis.setEx(
        `session:${sessionId}`,
        Math.floor((data.expiresAt.getTime() - Date.now()) / 1000),
        JSON.stringify(data)
      );
    } else {
      // ä½¿ç”¨æ•¸æ“šåº«
      await quickSessionRepository.upsert({
        id: sessionId,
        session_data: data,
        expires_at: data.expiresAt,
        last_accessed_at: data.lastAccessedAt
      });
    }
  }
  
  // åŠ è¼‰Session
  private async loadSession(sessionId: string): Promise<SessionData | null> {
    // å„ªå…ˆä½¿ç”¨Redis
    if (process.env.REDIS_URL) {
      const redis = require('redis').createClient({ url: process.env.REDIS_URL });
      const data = await redis.get(`session:${sessionId}`);
      return data ? JSON.parse(data) : null;
    } else {
      // ä½¿ç”¨æ•¸æ“šåº«
      const session = await quickSessionRepository.findById(sessionId);
      return session ? session.session_data : null;
    }
  }
  
  // åˆªé™¤Session
  private async deleteSession(sessionId: string): Promise<void> {
    if (process.env.REDIS_URL) {
      const redis = require('redis').createClient({ url: process.env.REDIS_URL });
      await redis.del(`session:${sessionId}`);
    } else {
      await quickSessionRepository.delete(sessionId);
    }
  }
  
  // æ¸…ç†éæœŸSessionï¼ˆå®šæ™‚ä»»å‹™èª¿ç”¨ï¼‰
  async cleanupExpiredSessions(): Promise<number> {
    const now = new Date();
    // æ¸…ç†é‚è¼¯...
    return 0;
  }
}
```

---

## ğŸ“š ç›¸é—œæ–‡æª”

- [å¾Œç«¯æ¶æ§‹è¨­è¨ˆ](./01-å¾Œç«¯æ¶æ§‹è¨­è¨ˆ.md)
- [æœå‹™å±¤è¨­è¨ˆ](./04-æœå‹™å±¤è¨­è¨ˆ.md)
- [APIè¨­è¨ˆ](./03-APIè¨­è¨ˆ.md)

---

**æ–‡æª”ç‰ˆæœ¬**ï¼šv1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2024å¹´

