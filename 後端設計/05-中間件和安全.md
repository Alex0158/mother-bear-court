# ä¸­é–“ä»¶å’Œå®‰å…¨

**æ–‡æª”ç‰ˆæœ¬**ï¼šv1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2024å¹´

---

## ğŸ›¡ï¸ å®‰å…¨è¨­è¨ˆæ¦‚è¿°

### å®‰å…¨åŸå‰‡

1. **æœ€å°æ¬Šé™åŸå‰‡**ï¼šç”¨æˆ¶åªèƒ½è¨ªå•æˆæ¬Šçš„è³‡æº
2. **æ·±åº¦é˜²ç¦¦**ï¼šå¤šå±¤å®‰å…¨é˜²è­·
3. **è¼¸å…¥é©—è­‰**ï¼šæ‰€æœ‰è¼¸å…¥éƒ½å¿…é ˆé©—è­‰
4. **è¼¸å‡ºç·¨ç¢¼**ï¼šé˜²æ­¢XSSæ”»æ“Š
5. **æ•æ„Ÿæ•¸æ“šåŠ å¯†**ï¼šå¯†ç¢¼ã€Tokenç­‰æ•æ„Ÿæ•¸æ“šåŠ å¯†å­˜å„²

### å®‰å…¨å±¤ç´š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ‡‰ç”¨å±¤å®‰å…¨ï¼ˆèªè­‰ã€æˆæ¬Šï¼‰        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   æ•¸æ“šå±¤å®‰å…¨ï¼ˆåŠ å¯†ã€é©—è­‰ï¼‰        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ç¶²çµ¡å±¤å®‰å…¨ï¼ˆHTTPSã€CORSï¼‰      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   åŸºç¤è¨­æ–½å®‰å…¨ï¼ˆé˜²ç«ç‰†ã€DDoSï¼‰   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ” èªè­‰ä¸­é–“ä»¶

### JWTèªè­‰ä¸­é–“ä»¶

**æ–‡ä»¶**ï¼š`src/middleware/auth.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { AppError } from '../utils/errors';

interface UserPayload {
  id: string;
  email: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: UserPayload;
      sessionId?: string; // å¿«é€Ÿé«”é©—æ¨¡å¼çš„Session ID
    }
  }
}

export const authenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // 1. å¾Headerç²å–Token
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      throw new AppError(401, 'UNAUTHORIZED', 'æœªæä¾›èªè­‰Token');
    }
    
    const token = authHeader.substring(7);
    
    // 2. é©—è­‰Token
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as UserPayload;
    
    // 3. æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å­˜åœ¨ä¸”æ¿€æ´»
    const user = await userRepository.findById(decoded.id);
    if (!user || !user.is_active) {
      throw new AppError(401, 'UNAUTHORIZED', 'ç”¨æˆ¶ä¸å­˜åœ¨æˆ–æœªæ¿€æ´»');
    }
    
    // 4. å°‡ç”¨æˆ¶ä¿¡æ¯é™„åŠ åˆ°è«‹æ±‚å°è±¡
    req.user = {
      id: user.id,
      email: user.email
    };
    
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError(401, 'INVALID_TOKEN', 'Tokenç„¡æ•ˆ'));
    } else if (error instanceof jwt.TokenExpiredError) {
      next(new AppError(401, 'TOKEN_EXPIRED', 'Tokenå·²éæœŸ'));
    } else {
      next(error);
    }
  }
};

// å¯é¸èªè­‰ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
export const optionalAuthenticate = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as UserPayload;
      const user = await userRepository.findById(decoded.id);
      if (user && user.is_active) {
        req.user = {
          id: user.id,
          email: user.email
        };
      }
    }
    next();
  } catch (error) {
    // èªè­‰å¤±æ•—ä¸å½±éŸ¿è«‹æ±‚ç¹¼çºŒ
    next();
  }
};

// Sessioné©—è­‰ä¸­é–“ä»¶ï¼ˆå¿«é€Ÿé«”é©—æ¨¡å¼ï¼‰
export const validateSession = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const sessionId = req.query.session_id as string || req.headers['x-session-id'] as string;
    
    if (!sessionId) {
      throw new AppError(400, 'SESSION_ID_REQUIRED', 'Session IDæ˜¯å¿…éœ€çš„');
    }
    
    // é©—è­‰Session IDæ ¼å¼
    if (!sessionId.startsWith('guest_')) {
      throw new AppError(400, 'INVALID_SESSION_ID', 'ç„¡æ•ˆçš„Session IDæ ¼å¼');
    }
    
    // é©—è­‰Sessionæ˜¯å¦å­˜åœ¨ä¸”æœªéæœŸ
    const session = await sessionService.getSession(sessionId);
    if (!session) {
      throw new AppError(401, 'SESSION_EXPIRED', 'Sessionå·²éæœŸæˆ–ä¸å­˜åœ¨');
    }
    
    // å°‡Session IDé™„åŠ åˆ°è«‹æ±‚å°è±¡
    req.sessionId = sessionId;
    
    next();
  } catch (error) {
    next(error);
  }
};
```

### ä½¿ç”¨æ–¹å¼

```typescript
// éœ€è¦èªè­‰çš„è·¯ç”±
router.get('/profile', authenticate, userController.getProfile);

// å¯é¸èªè­‰çš„è·¯ç”±
router.post('/cases/quick', optionalAuthenticate, caseController.createQuickCase);
```

---

## ğŸ”’ æˆæ¬Šä¸­é–“ä»¶

### è³‡æºæ‰€æœ‰æ¬Šé©—è­‰

```typescript
export const authorizeResource = (resourceType: 'case' | 'judgment' | 'pairing') => {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      if (!req.user) {
        throw new AppError(401, 'UNAUTHORIZED', 'æœªèªè­‰');
      }
      
      const resourceId = req.params.id;
      let hasAccess = false;
      
      switch (resourceType) {
        case 'case':
          hasAccess = await caseRepository.hasAccess(resourceId, req.user.id);
          break;
        case 'judgment':
          hasAccess = await judgmentRepository.hasAccess(resourceId, req.user.id);
          break;
        case 'pairing':
          hasAccess = await pairingRepository.hasAccess(resourceId, req.user.id);
          break;
      }
      
      if (!hasAccess) {
        throw new AppError(403, 'FORBIDDEN', 'ç„¡æ¬Šé™è¨ªå•æ­¤è³‡æº');
      }
      
      next();
    } catch (error) {
      next(error);
    }
  };
};
```

### ä½¿ç”¨æ–¹å¼

```typescript
router.get(
  '/cases/:id',
  authenticate,
  authorizeResource('case'),
  caseController.getCaseById
);
```

---

## âœ… è«‹æ±‚é©—è­‰ä¸­é–“ä»¶

### Joié©—è­‰ä¸­é–“ä»¶

**æ–‡ä»¶**ï¼š`src/middleware/validator.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import Joi from 'joi';
import { AppError } from '../utils/errors';

export const validate = (schema: {
  body?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
}) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const errors: string[] = [];
    
    // é©—è­‰è«‹æ±‚é«”
    if (schema.body) {
      const { error } = schema.body.validate(req.body, { abortEarly: false });
      if (error) {
        errors.push(...error.details.map(d => d.message));
      }
    }
    
    // é©—è­‰è·¯å¾‘åƒæ•¸
    if (schema.params) {
      const { error } = schema.params.validate(req.params, { abortEarly: false });
      if (error) {
        errors.push(...error.details.map(d => d.message));
      }
    }
    
    // é©—è­‰æŸ¥è©¢åƒæ•¸
    if (schema.query) {
      const { error } = schema.query.validate(req.query, { abortEarly: false });
      if (error) {
        errors.push(...error.details.map(d => d.message));
      }
    }
    
    if (errors.length > 0) {
      next(new AppError(400, 'VALIDATION_ERROR', errors.join('; ')));
      return;
    }
    
    next();
  };
};
```

### é©—è­‰Schemaå®šç¾©

**æ–‡ä»¶**ï¼š`src/utils/validation.ts`

```typescript
import Joi from 'joi';

// è¨»å†Šé©—è­‰
export const registerSchema = {
  body: Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().min(8).pattern(/[a-zA-Z]/).pattern(/[0-9]/).required(),
    nickname: Joi.string().min(2).max(50).optional()
  })
};

// ç™»éŒ„é©—è­‰
export const loginSchema = {
  body: Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().required()
  })
};

// å‰µå»ºæ¡ˆä»¶é©—è­‰
export const createCaseSchema = {
  body: Joi.object({
    pairing_id: Joi.string().uuid().required(),
    title: Joi.string().min(5).max(200).required(),
    plaintiff_statement: Joi.string().min(50).max(2000).required(),
    defendant_statement: Joi.string().min(50).max(2000).optional(),
    evidence_urls: Joi.array().items(Joi.string().uri()).max(3).optional()
  })
};

// å¿«é€Ÿé«”é©—æ¡ˆä»¶é©—è­‰
export const quickCaseSchema = {
  body: Joi.object({
    plaintiff_statement: Joi.string().min(50).max(2000).required(),
    defendant_statement: Joi.string().min(50).max(2000).required(),
    evidence_urls: Joi.array().items(Joi.string().uri()).max(3).optional()
  })
};
```

### ä½¿ç”¨æ–¹å¼

```typescript
import { validate } from '../middleware/validator';
import { registerSchema } from '../utils/validation';

router.post('/register', validate(registerSchema), authController.register);
```

---

## ğŸš¦ é™æµä¸­é–“ä»¶

### APIé™æµ

**æ–‡ä»¶**ï¼š`src/middleware/rateLimiter.ts`

```typescript
import rateLimit from 'express-rate-limit';
import { Request, Response } from 'express';

// é€šç”¨é™æµï¼ˆæ¯åˆ†é˜100æ¬¡ï¼‰
export const generalLimiter = rateLimit({
  windowMs: 60 * 1000, // 1åˆ†é˜
  max: 100,
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
    }
  },
  standardHeaders: true,
  legacyHeaders: false
});

// èªè­‰æ¥å£é™æµï¼ˆæ¯5åˆ†é˜10æ¬¡ï¼‰
export const authLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5åˆ†é˜
  max: 10,
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'èªè­‰è«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
    }
  },
  skipSuccessfulRequests: true // æˆåŠŸè«‹æ±‚ä¸è¨ˆå…¥é™æµ
});

// è¨»å†Šæ¥å£é™æµï¼ˆæ¯å°æ™‚5æ¬¡ï¼‰
export const registerLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1å°æ™‚
  max: 5,
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'è¨»å†Šè«‹æ±‚éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
    }
  }
});

// é©—è­‰ç¢¼æ¥å£é™æµï¼ˆæ¯éƒµç®±æ¯5åˆ†é˜1æ¬¡ï¼‰
export const verificationCodeLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5åˆ†é˜
  max: 1,
  keyGenerator: (req: Request) => {
    return req.body.email || req.ip;
  },
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'é©—è­‰ç¢¼ç™¼é€éæ–¼é »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
    }
  }
});
```

### ä½¿ç”¨æ–¹å¼

```typescript
router.post('/register', registerLimiter, validate(registerSchema), authController.register);
router.post('/send-verification-code', verificationCodeLimiter, authController.sendVerificationCode);
```

---

## ğŸ“ æ—¥èªŒä¸­é–“ä»¶

### è«‹æ±‚æ—¥èªŒ

**æ–‡ä»¶**ï¼š`src/middleware/logger.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }));
}

export const requestLogger = (req: Request, res: Response, next: NextFunction): void => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    const logData = {
      method: req.method,
      url: req.url,
      status: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      userId: req.user?.id
    };
    
    if (res.statusCode >= 400) {
      logger.warn('HTTP Request', logData);
    } else {
      logger.info('HTTP Request', logData);
    }
  });
  
  next();
};
```

---

## âš ï¸ éŒ¯èª¤è™•ç†ä¸­é–“ä»¶

### çµ±ä¸€éŒ¯èª¤è™•ç†

**æ–‡ä»¶**ï¼š`src/middleware/errorHandler.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors';
import logger from '../config/logger';

export const errorHandler = (
  err: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // è¨˜éŒ„éŒ¯èª¤
  logger.error('Error occurred', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    userId: req.user?.id
  });
  
  // è™•ç†è‡ªå®šç¾©éŒ¯èª¤
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      success: false,
      error: {
        code: err.code,
        message: err.message,
        details: err.details || {}
      }
    });
    return;
  }
  
  // è™•ç†æœªçŸ¥éŒ¯èª¤
  res.status(500).json({
    success: false,
    error: {
      code: 'INTERNAL_ERROR',
      message: process.env.NODE_ENV === 'production' 
        ? 'æœå‹™å™¨å…§éƒ¨éŒ¯èª¤' 
        : err.message
    }
  });
};
```

### è‡ªå®šç¾©éŒ¯èª¤é¡

**æ–‡ä»¶**ï¼š`src/utils/errors.ts`

```typescript
export class AppError extends Error {
  constructor(
    public statusCode: number,
    public code: string,
    public message: string,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = 'AppError';
    Error.captureStackTrace(this, this.constructor);
  }
}

// å¸¸ç”¨éŒ¯èª¤
export const Errors = {
  UNAUTHORIZED: (message = 'æœªèªè­‰') => new AppError(401, 'UNAUTHORIZED', message),
  FORBIDDEN: (message = 'ç„¡æ¬Šé™') => new AppError(403, 'FORBIDDEN', message),
  NOT_FOUND: (message = 'è³‡æºä¸å­˜åœ¨') => new AppError(404, 'NOT_FOUND', message),
  VALIDATION_ERROR: (message = 'é©—è­‰å¤±æ•—') => new AppError(400, 'VALIDATION_ERROR', message),
  INTERNAL_ERROR: (message = 'æœå‹™å™¨å…§éƒ¨éŒ¯èª¤') => new AppError(500, 'INTERNAL_ERROR', message)
};
```

---

## ğŸ”’ å®‰å…¨é˜²è­·

### CORSé…ç½®

```typescript
import cors from 'cors';

export const corsOptions: cors.CorsOptions = {
  origin: (origin, callback) => {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:5173'];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('ä¸å…è¨±çš„ä¾†æº'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(cors(corsOptions));
```

### Helmetå®‰å…¨é ­

```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:']
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

### SQLæ³¨å…¥é˜²è­·

ä½¿ç”¨Prisma ORMè‡ªå‹•é˜²è­·SQLæ³¨å…¥ï¼š

```typescript
// âœ… å®‰å…¨ï¼šä½¿ç”¨Prismaåƒæ•¸åŒ–æŸ¥è©¢
const user = await prisma.user.findUnique({
  where: { email: userEmail }
});

// âŒ ä¸å®‰å…¨ï¼šç›´æ¥æ‹¼æ¥SQLï¼ˆä¸è¦é€™æ¨£åšï¼‰
// const query = `SELECT * FROM users WHERE email = '${userEmail}'`;
```

### XSSé˜²è­·

1. **è¼¸å…¥é©—è­‰**ï¼šä½¿ç”¨Joié©—è­‰æ‰€æœ‰è¼¸å…¥
2. **è¼¸å‡ºç·¨ç¢¼**ï¼šä½¿ç”¨æ¨¡æ¿å¼•æ“è‡ªå‹•ç·¨ç¢¼
3. **Content Security Policy**ï¼šä½¿ç”¨Helmetè¨­ç½®CSP

### æ–‡ä»¶ä¸Šå‚³å®‰å…¨

```typescript
import multer from 'multer';
import path from 'path';

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼Œé˜²æ­¢è·¯å¾‘éæ­·
    const ext = path.extname(file.originalname);
    // é©—è­‰æ–‡ä»¶æ“´å±•å
    const allowedExts = ['.jpg', '.jpeg', '.png', '.gif', '.mp4'];
    if (!allowedExts.includes(ext.toLowerCase())) {
      return cb(new AppError(400, 'INVALID_FILE_TYPE', 'ä¸æ”¯æŒçš„æ–‡ä»¶é¡å‹'));
    }
    
    // æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤å±éšªå­—ç¬¦
    const safeName = file.originalname.replace(/[^a-zA-Z0-9.-]/g, '_');
    const uniqueName = `${Date.now()}-${Math.round(Math.random() * 1E9)}${ext}`;
    cb(null, uniqueName);
  }
});

const fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'];
  
  // é©—è­‰MIMEé¡å‹
  if (!allowedTypes.includes(file.mimetype)) {
    return cb(new AppError(400, 'INVALID_FILE_TYPE', 'ä¸æ”¯æŒçš„æ–‡ä»¶é¡å‹'));
  }
  
  // é©—è­‰æ–‡ä»¶æ“´å±•åï¼ˆé˜²æ­¢MIMEé¡å‹å½é€ ï¼‰
  const ext = path.extname(file.originalname).toLowerCase();
  const allowedExts = ['.jpg', '.jpeg', '.png', '.gif', '.mp4'];
  if (!allowedExts.includes(ext)) {
    return cb(new AppError(400, 'INVALID_FILE_TYPE', 'ä¸æ”¯æŒçš„æ–‡ä»¶æ“´å±•å'));
  }
  
  cb(null, true);
};

export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
    files: 3 // æœ€å¤š3å€‹æ–‡ä»¶
  }
});
```

---

## ğŸ”‘ å¯†ç¢¼å®‰å…¨

### å¯†ç¢¼åŠ å¯†

```typescript
import bcrypt from 'bcrypt';

// åŠ å¯†å¯†ç¢¼
export const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 10;
  return await bcrypt.hash(password, saltRounds);
};

// é©—è­‰å¯†ç¢¼
export const comparePassword = async (
  password: string,
  hash: string
): Promise<boolean> => {
  return await bcrypt.compare(password, hash);
};
```

### å¯†ç¢¼å¼·åº¦é©—è­‰

```typescript
export const validatePasswordStrength = (password: string): { valid: boolean; message?: string } => {
  // è‡³å°‘8ä½
  if (password.length < 8) {
    return { valid: false, message: 'å¯†ç¢¼é•·åº¦è‡³å°‘8ä½' };
  }
  
  // æœ€å¤š128ä½ï¼ˆé˜²æ­¢DoSæ”»æ“Šï¼‰
  if (password.length > 128) {
    return { valid: false, message: 'å¯†ç¢¼é•·åº¦ä¸èƒ½è¶…é128ä½' };
  }
  
  // åŒ…å«å­—æ¯
  if (!/[a-zA-Z]/.test(password)) {
    return { valid: false, message: 'å¯†ç¢¼å¿…é ˆåŒ…å«å­—æ¯' };
  }
  
  // åŒ…å«æ•¸å­—
  if (!/[0-9]/.test(password)) {
    return { valid: false, message: 'å¯†ç¢¼å¿…é ˆåŒ…å«æ•¸å­—' };
  }
  
  // æª¢æŸ¥å¸¸è¦‹å¼±å¯†ç¢¼
  const commonPasswords = ['password', '12345678', 'qwerty', 'abc123'];
  if (commonPasswords.includes(password.toLowerCase())) {
    return { valid: false, message: 'å¯†ç¢¼éæ–¼ç°¡å–®ï¼Œè«‹ä½¿ç”¨æ›´è¤‡é›œçš„å¯†ç¢¼' };
  }
  
  return { valid: true };
};
```

---

## ğŸ“Š å®‰å…¨ç›£æ§

### ç•°å¸¸ç™»éŒ„æª¢æ¸¬

```typescript
export const detectAnomalousLogin = async (
  userId: string,
  ip: string,
  userAgent: string
): Promise<boolean> => {
  // æª¢æŸ¥IPæ˜¯å¦ç•°å¸¸
  const recentLogins = await loginHistoryRepository.findRecent(userId, 24); // æœ€è¿‘24å°æ™‚
  const uniqueIPs = new Set(recentLogins.map(l => l.ip));
  
  // å¦‚æœå‡ºç¾æ–°IPï¼Œè¨˜éŒ„è­¦å‘Š
  if (!uniqueIPs.has(ip)) {
    logger.warn('Anomalous login detected', { userId, ip, userAgent });
    // å¯é¸ï¼šç™¼é€éƒµä»¶é€šçŸ¥
    await emailService.sendSecurityAlert(userId, ip);
  }
  
  return true;
};
```

### Sessionå®‰å…¨é©—è­‰

```typescript
// é©—è­‰Session IDæ ¼å¼å’Œæœ‰æ•ˆæ€§
export const validateSessionId = (sessionId: string): boolean => {
  // æ ¼å¼ï¼šguest_timestamp_random
  const pattern = /^guest_\d+_[a-z0-9]{6,}$/;
  if (!pattern.test(sessionId)) {
    return false;
  }
  
  // æå–æ™‚é–“æˆ³ï¼Œæª¢æŸ¥æ˜¯å¦åœ¨åˆç†ç¯„åœå…§ï¼ˆä¸è¶…é24å°æ™‚ï¼‰
  const parts = sessionId.split('_');
  if (parts.length !== 3) {
    return false;
  }
  
  const timestamp = parseInt(parts[1]);
  const now = Date.now();
  const maxAge = 24 * 60 * 60 * 1000; // 24å°æ™‚
  
  if (timestamp < now - maxAge || timestamp > now + 60000) { // å…è¨±1åˆ†é˜èª¤å·®
    return false;
  }
  
  return true;
};

// é˜²æ­¢Sessionæšèˆ‰æ”»æ“Š
export const rateLimitSessionCreation = async (ip: string): Promise<boolean> => {
  const key = `session_creation:${ip}`;
  const count = await redis.incr(key);
  
  if (count === 1) {
    await redis.expire(key, 3600); // 1å°æ™‚
  }
  
  // æ¯å°æ™‚æœ€å¤šå‰µå»º10å€‹Session
  if (count > 10) {
    return false;
  }
  
  return true;
};
```

---

## ğŸ“š ç›¸é—œæ–‡æª”

- [å¾Œç«¯æ¶æ§‹è¨­è¨ˆ](./01-å¾Œç«¯æ¶æ§‹è¨­è¨ˆ.md)
- [APIè¨­è¨ˆ](./03-APIè¨­è¨ˆ.md)
- [æœå‹™å±¤è¨­è¨ˆ](./04-æœå‹™å±¤è¨­è¨ˆ.md)

---

**æ–‡æª”ç‰ˆæœ¬**ï¼šv1.0  
**æœ€å¾Œæ›´æ–°**ï¼š2024å¹´

