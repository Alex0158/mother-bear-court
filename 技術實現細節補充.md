# 技術實現細節補充

## 🎯 本文檔目的

補充和完善所有技術實現的細節，確保開發時沒有遺漏。

---

## 1. 快速體驗模式的Session管理

### 1.1 Session生成和管理

**Session生成**：
- 用戶進入快速體驗模式時，自動生成臨時Session ID
- Session ID格式：`guest_${timestamp}_${randomString}`（如：`guest_1704067200_abc123`）
- 存儲在瀏覽器LocalStorage或Cookie中
- 有效期：24小時（從創建時間開始計算）

**Session存儲**：
- **前端**：LocalStorage存儲Session ID
- **後端**：Redis或內存緩存存儲Session數據
  - Key：`session:${sessionId}`
  - Value：JSON格式的案件數據
  - TTL：24小時（自動過期）

**Session數據結構**：
```json
{
  "sessionId": "guest_1704067200_abc123",
  "createdAt": "2024-01-01T00:00:00Z",
  "expiresAt": "2024-01-02T00:00:00Z",
  "caseData": {
    "roleAStatement": "...",
    "roleBStatement": "...",
    "evidences": [],
    "submittedAt": null,
    "judgmentId": null
  }
}
```

### 1.2 數據清理機制

**自動清理**：
- Redis TTL自動過期（24小時）
- 定時任務：每天凌晨清理過期Session（備用機制）

**手動清理**：
- 用戶關閉瀏覽器標籤頁時，不立即清理（保留24小時）
- 用戶明確點擊「放棄」時，立即清理

**清理策略**：
- 過期Session數據自動刪除
- 已提交並獲得判決的Session，保留7天（供用戶查看判決）
- 7天後自動清理

### 1.3 數據遷移到完整模式

**遷移觸發**：
- 用戶在判決後點擊「保存記錄，立即註冊」
- 用戶註冊成功後，自動關聯當前Session的案件數據

**遷移流程**：
1. 用戶註冊成功，獲得User ID
2. 系統讀取當前Session的案件數據
3. 創建案件記錄（關聯User ID）
4. 創建判決記錄（關聯案件ID）
5. 刪除臨時Session數據
6. 提示用戶：「案件已保存到您的帳號」

**遷移失敗處理**：
- 如果遷移失敗，保留Session數據
- 提示用戶：「保存失敗，請稍後重試」
- 提供「稍後保存」選項

---

## 2. AI自動判斷案件類型的實現細節

### 2.1 判斷方法

**方法1：使用OpenAI API分類**（推薦）：
```javascript
async function classifyCaseType(statementA, statementB) {
  const prompt = `
請分析以下兩個陳述，判斷案件類型。只返回類型名稱，不要其他內容。

案件類型選項：
1. 生活習慣衝突
2. 消費決策衝突
3. 社交關係衝突
4. 價值觀衝突
5. 情感需求衝突
6. 其他衝突

角色A陳述：${statementA}
角色B陳述：${statementB}

請返回類型名稱：
`;

  const response = await openai.chat.completions.create({
    model: "gpt-3.5-turbo",
    messages: [{ role: "user", content: prompt }],
    temperature: 0.3, // 降低溫度，提高準確性
    max_tokens: 50
  });

  return response.choices[0].message.content.trim();
}
```

**方法2：使用關鍵詞匹配**（降級方案）：
- 如果OpenAI API失敗，使用關鍵詞匹配
- 預設關鍵詞庫，匹配案件類型
- 準確度較低，但可以作為備用

### 2.2 判斷失敗的降級方案

**降級策略**：
1. **重試機制**：失敗後重試2次（總共3次）
2. **關鍵詞匹配**：如果API失敗，使用關鍵詞匹配
3. **默認類型**：如果都失敗，使用「其他衝突」作為默認類型
4. **用戶提示**：提示用戶「AI無法自動判斷類型，已使用默認類型」

**錯誤處理**：
```javascript
async function classifyCaseTypeWithFallback(statementA, statementB) {
  try {
    // 方法1：OpenAI API
    return await classifyCaseType(statementA, statementB);
  } catch (error) {
    console.error('OpenAI API failed:', error);
    
    try {
      // 方法2：關鍵詞匹配
      return await keywordMatch(statementA, statementB);
    } catch (error) {
      console.error('Keyword match failed:', error);
      
      // 方法3：默認類型
      return '其他衝突';
    }
  }
}
```

### 2.3 判斷結果的置信度

**置信度計算**（可選，未來實現）：
- OpenAI API返回的confidence score
- 關鍵詞匹配的匹配度
- 如果置信度低於閾值（如0.7），提示用戶確認

---

## 3. 責任分比例的計算和驗證

### 3.1 AI生成責任分比例

**Prompt要求**：
- 在Prompt中明確要求：責任分比例總和必須是100%
- 要求AI以JSON格式返回，便於驗證

**Prompt示例**：
```
請在判決結果中明確責任分比例，格式如下：
{
  "roleA": 60,
  "roleB": 40,
  "reason": "角色A主要責任，因為..."
}

要求：
- roleA + roleB 必須等於 100
- 比例範圍：0-100
- 必須說明理由
```

### 3.2 比例驗證和修正

**驗證邏輯**：
```javascript
function validateAndFixResponsibility(roleA, roleB) {
  const total = roleA + roleB;
  
  if (total === 100) {
    return { roleA, roleB, valid: true };
  }
  
  // 如果總和不等於100，按比例調整
  if (total > 0) {
    const adjustedA = Math.round((roleA / total) * 100);
    const adjustedB = 100 - adjustedA;
    return { 
      roleA: adjustedA, 
      roleB: adjustedB, 
      valid: false,
      adjusted: true 
    };
  }
  
  // 如果都是0，默認各50%
  return { 
    roleA: 50, 
    roleB: 50, 
    valid: false,
    adjusted: true,
    reason: 'AI未返回有效比例，使用默認值'
  };
}
```

**極端情況處理**：
- **0%或100%**：如果AI判斷一方完全無責任或完全有責任，允許0%或100%
- **驗證通過**：只要總和是100%，就接受結果
- **日誌記錄**：記錄所有調整情況，用於優化

---

## 4. 單人雙角色介面的邊界情況處理

### 4.1 只有一方填寫的情況

**快速體驗模式**：
- 顯示提示：「只有一方填寫，我可以代為填寫」
- 提供「代為填寫」按鈕
- 點擊後，允許用戶在另一個輸入框填寫

**完整模式**：
- 顯示提示：「等待對方填寫」
- 發送郵件通知對方
- 提供「提醒對方」按鈕

### 4.2 輸入內容驗證

**字數驗證**：
- **最少50字**：
  - 實時檢查，少於50字時顯示提示：「至少需要50字」
  - 提交時再次驗證，不滿足條件不允許提交
- **最多2000字**：
  - 實時字數統計
  - 超過2000字時，截斷或提示「超過字數限制」

**內容驗證**：
- **空內容檢測**：檢測是否只有空格或換行
- **重複內容檢測**：檢測是否大量重複相同字符
- **惡意輸入檢測**：
  - 檢測是否包含大量特殊字符
  - 檢測是否包含明顯的垃圾內容
  - 檢測是否包含敏感詞（可選）

**驗證邏輯**：
```javascript
function validateStatement(statement) {
  // 1. 字數檢查
  const wordCount = statement.trim().length;
  if (wordCount < 50) {
    return { valid: false, error: '至少需要50字' };
  }
  if (wordCount > 2000) {
    return { valid: false, error: '最多2000字' };
  }
  
  // 2. 空內容檢查
  if (statement.trim().length === 0) {
    return { valid: false, error: '內容不能為空' };
  }
  
  // 3. 重複內容檢查
  const repeatedChar = /(.)\1{20,}/.test(statement);
  if (repeatedChar) {
    return { valid: false, error: '內容包含過多重複字符' };
  }
  
  // 4. 惡意輸入檢查（可選）
  const suspiciousPattern = /[^\w\s\u4e00-\u9fa5]{50,}/.test(statement);
  if (suspiciousPattern) {
    return { valid: false, error: '內容包含過多特殊字符' };
  }
  
  return { valid: true };
}
```

### 4.3 提交按鈕狀態

**按鈕狀態邏輯**：
- **雙方都未填寫**：按鈕禁用，顯示「請填寫雙方陳述」
- **只有一方填寫**：
  - 快速體驗模式：顯示「我可以代為填寫」或「提交案件（僅一方）」
  - 完整模式：顯示「等待對方填寫」
- **雙方都填寫**：按鈕啟用，顯示「提交案件」

---

## 5. AI API失敗的降級方案

### 5.1 重試機制

**重試策略**：
- 最多重試3次
- 指數退避：第1次等待1秒，第2次等待2秒，第3次等待4秒
- 只對網絡錯誤和5xx錯誤重試
- 4xx錯誤（如限額超標）不重試

**實現**：
```javascript
async function callOpenAIWithRetry(prompt, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7,
        max_tokens: 2000
      });
      return response;
    } catch (error) {
      // 4xx錯誤不重試
      if (error.status >= 400 && error.status < 500) {
        throw error;
      }
      
      // 最後一次重試失敗，拋出錯誤
      if (i === maxRetries - 1) {
        throw error;
      }
      
      // 指數退避
      await sleep(1000 * Math.pow(2, i));
    }
  }
}
```

### 5.2 降級方案

**方案1：使用緩存判決**（優先）：
- 如果API失敗，查找相似案件的緩存判決
- 如果找到，使用緩存判決（標註「來自緩存」）

**方案2：使用模板判決**（備用）：
- 如果沒有緩存，使用預設的模板判決
- 模板判決是通用的，不包含具體分析
- 提示用戶：「AI服務暫時不可用，已提供通用判決」

**方案3：提示用戶稍後重試**（最後）：
- 如果都失敗，提示用戶：「AI服務暫時不可用，請稍後重試」
- 保存案件數據，允許用戶稍後重新生成判決
- 提供「稍後重試」功能

**實現**：
```javascript
async function generateJudgmentWithFallback(caseData) {
  try {
    // 方法1：調用AI API
    return await callOpenAIWithRetry(buildPrompt(caseData));
  } catch (error) {
    console.error('AI API failed:', error);
    
    // 方法2：使用緩存
    const cached = await getCachedJudgment(caseData);
    if (cached) {
      return { ...cached, source: 'cache' };
    }
    
    // 方法3：使用模板
    const template = getTemplateJudgment(caseData.type);
    if (template) {
      return { ...template, source: 'template' };
    }
    
    // 方法4：提示稍後重試
    throw new Error('AI服務暫時不可用，請稍後重試');
  }
}
```

---

## 6. 數據庫連接失敗處理

### 6.1 連接池配置

**配置**：
- 最大連接數：10
- 最小連接數：2
- 連接超時：5秒
- 查詢超時：30秒

### 6.2 失敗處理

**重試機制**：
- 連接失敗時，自動重試3次
- 每次重試間隔1秒

**降級方案**：
- 如果數據庫完全不可用：
  - 快速體驗模式：使用內存緩存（臨時）
  - 完整模式：提示用戶「服務暫時不可用，請稍後重試」

---

## 7. 文件上傳失敗處理

### 7.1 上傳重試

**重試機制**：
- 網絡錯誤：自動重試3次
- 服務器錯誤：自動重試3次
- 文件格式錯誤：不重試，直接提示

### 7.2 降級方案

**方案1：允許跳過**：
- 如果上傳失敗，允許用戶跳過證據上傳
- 提示：「證據上傳失敗，可以跳過繼續提交」

**方案2：稍後上傳**：
- 保存案件草稿，允許用戶稍後上傳證據
- 提供「稍後上傳」功能

---

## 8. 性能優化細節

### 8.1 緩存策略

**判決結果緩存**：
- Key：`judgment:${caseType}:${hash(statements)}`
- TTL：24小時
- 存儲：Redis（生產環境）或內存緩存（開發環境）

**案件類型判斷緩存**：
- Key：`caseType:${hash(statements)}`
- TTL：7天（類型判斷結果相對穩定）
- 存儲：Redis或內存緩存

### 8.2 並發處理

**並發限制**：
- AI API並發請求：最多5個同時進行
- 使用隊列管理請求，避免超過API限額

**實現**：
```javascript
class AIRequestQueue {
  constructor(maxConcurrent = 5) {
    this.queue = [];
    this.running = 0;
    this.maxConcurrent = maxConcurrent;
  }
  
  async add(request) {
    return new Promise((resolve, reject) => {
      this.queue.push({ request, resolve, reject });
      this.process();
    });
  }
  
  async process() {
    if (this.running >= this.maxConcurrent || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const { request, resolve, reject } = this.queue.shift();
    
    try {
      const result = await request();
      resolve(result);
    } catch (error) {
      reject(error);
    } finally {
      this.running--;
      this.process();
    }
  }
}
```

### 8.3 數據庫查詢優化

**索引優化**：
- 所有外鍵字段加索引
- 常用查詢字段加索引
- 時間字段加索引

**查詢優化**：
- 使用分頁查詢，避免一次性查詢大量數據
- 使用SELECT指定字段，避免SELECT *
- 使用JOIN優化關聯查詢

---

## 9. 安全性細節

### 9.1 輸入驗證

**XSS防護**：
- 所有用戶輸入進行HTML轉義
- 使用CSP（Content Security Policy）
- 使用安全的模板引擎（如React自動轉義）

**SQL注入防護**：
- 使用ORM或參數化查詢
- 禁止直接拼接SQL語句
- 輸入驗證和過濾

**文件上傳安全**：
- 驗證文件類型（MIME類型和文件擴展名）
- 驗證文件大小
- 掃描文件內容（可選，使用病毒掃描）

### 9.2 敏感信息保護

**自動檢測**：
- 電話號碼：正則表達式檢測
- 身份證號：正則表達式檢測
- 地址：關鍵詞檢測
- 郵箱：正則表達式檢測

**處理方式**：
- 提示用戶：「檢測到敏感信息，建議遮擋」
- 提供手動遮擋工具
- 上傳前預覽確認

---

## 10. 監控和日誌

### 10.1 日誌記錄

**日誌級別**：
- ERROR：錯誤和異常
- WARN：警告（如API限額接近）
- INFO：重要操作（如案件提交、判決生成）
- DEBUG：調試信息（開發環境）

**日誌內容**：
- 時間戳
- 用戶ID（如有）
- Session ID（快速體驗模式）
- 操作類型
- 請求參數（脫敏）
- 響應結果
- 錯誤信息（如有）

### 10.2 監控指標

**系統指標**：
- API響應時間
- 數據庫查詢時間
- 錯誤率
- 並發請求數

**業務指標**：
- 案件提交數
- 判決生成數
- AI API調用次數
- 緩存命中率

**告警機制**：
- 錯誤率超過5%：發送告警
- API響應時間超過10秒：發送告警
- 數據庫連接失敗：發送告警

---

## 11. 測試策略

### 11.1 單元測試

**測試覆蓋**：
- 核心業務邏輯：80%+覆蓋率
- 工具函數：100%覆蓋率
- API路由：主要路徑測試

**測試內容**：
- 輸入驗證邏輯
- 責任分比例驗證
- 案件類型判斷
- 緩存邏輯

### 11.2 集成測試

**測試內容**：
- 完整流程測試（提交→AI分析→判決）
- 錯誤處理測試
- 降級方案測試
- 數據遷移測試

### 11.3 用戶測試

**測試場景**：
- 快速體驗模式完整流程
- 註冊和配對流程
- 進階功能使用
- 錯誤情況處理

---

## 12. 部署和運維

### 12.1 環境變量

**必需環境變量**：
- `DATABASE_URL`：數據庫連接字符串
- `OPENAI_API_KEY`：OpenAI API密鑰
- `JWT_SECRET`：JWT簽名密鑰
- `REDIS_URL`：Redis連接字符串（可選）

**可選環境變量**：
- `SMTP_HOST`：郵件服務器
- `SMTP_USER`：郵件用戶名
- `SMTP_PASS`：郵件密碼
- `FILE_STORAGE_TYPE`：文件存儲類型（local/cloud）

### 12.2 健康檢查

**健康檢查端點**：
- `GET /health`：基本健康檢查
- `GET /health/db`：數據庫連接檢查
- `GET /health/redis`：Redis連接檢查（如有）
- `GET /health/ai`：AI API連接檢查（可選）

**檢查內容**：
- 服務器運行狀態
- 數據庫連接狀態
- 關鍵服務可用性

---

**最後更新**：2024年  
**文檔版本**：v1.0（技術實現細節補充）

